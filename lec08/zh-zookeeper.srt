1
00:00:01,600 --> 00:00:05,000
好的，上次我开始说话的时候
alright last time I started talking

2
00:00:05,000 --> 00:00:06,770
关于线性化能力，我想
about linearize ability and I want to

3
00:00:06,770 --> 00:00:09,290
结束这一次，我们之所以要
finish up this time the reason why we're

4
00:00:09,290 --> 00:00:11,660
再说一遍就是这是我们的
talking about it again is that it's our

5
00:00:11,660 --> 00:00:14,000
一种关于什么的标准定义
kind of standard definition for what

6
00:00:14,000 --> 00:00:19,039
强一致性意味着在存储方面
strong consistency means in storage

7
00:00:19,039 --> 00:00:23,079
设置系统样式，例如，实验3是
style systems so for example lab 3 is a

8
00:00:23,079 --> 00:00:28,369
需要服从你的实验室3需要
needs to obey your lab 3 needs to be

9
00:00:28,369 --> 00:00:31,369
可线性化，有时这将
linearizable and sometimes this will

10
00:00:31,369 --> 00:00:32,930
上来吧，因为我们在谈论一个
come up because we're talking about a

11
00:00:32,930 --> 00:00:34,310
高度一致的系统，我们正在
strongly consistent system and we're

12
00:00:34,310 --> 00:00:35,360
想知道一种特定的行为
wondering whether a particular behavior

13
00:00:35,360 --> 00:00:39,170
是可以接受的，其他时候是线性化的
is acceptable and other times linearize

14
00:00:39,170 --> 00:00:40,760
能力会变得越来越强，因为
ability will become come up because

15
00:00:40,760 --> 00:00:42,140
我们将谈论的是一种
we'll be talking about a system that

16
00:00:42,140 --> 00:00:44,000
是不可线性化的，我们将会
isn't linearizable and we'll be

17
00:00:44,000 --> 00:00:47,150
想知道你知道它会以什么方式
wondering you know in what ways might it

18
00:00:47,150 --> 00:00:49,520
达不到线性化或偏离线性化
fall short or deviate from linearize

19
00:00:49,520 --> 00:00:51,350
能力所以你需要做的一件事就是
ability so one thing you need to be able

20
00:00:51,350 --> 00:00:55,160
要做的就是观察特定的序列
to do is look at a particular sequence

21
00:00:55,160 --> 00:00:59,150
操作的特定执行
of operations a particular execution of

22
00:00:59,150 --> 00:01:00,950
一些执行读取和
some system that executes reads and

23
00:01:00,950 --> 00:01:03,260
像你的实验3一样写作，并且能够
writes like your lab 3 and be able to

24
00:01:03,260 --> 00:01:04,699
回答我的问题哦，就是这样吗？
answer the question oh was that was that

25
00:01:04,699 --> 00:01:06,609
史蒂文斯的行动我刚刚看到了
Stevens of operations I just saw

26
00:01:06,609 --> 00:01:10,490
不管是不是可以线性化，我都要去，所以我们要走了
linearizable or not I'm so we're going

27
00:01:10,490 --> 00:01:11,929
继续练习这一点
to continue practicing that a little bit

28
00:01:11,929 --> 00:01:16,549
现在再加上我会试着确定
now plus I'll try to actually establish

29
00:01:16,549 --> 00:01:17,719
一些有趣的事实将会是
some interesting facts that will be

30
00:01:17,719 --> 00:01:19,789
对我们了解它的意义很有帮助
helpful for us about what it means about

31
00:01:19,789 --> 00:01:21,829
对我们的系统造成的后果
the consequences for the systems we

32
00:01:21,829 --> 00:01:26,630
构建和查看线性化能力是
build and look at linearize ability is

33
00:01:26,630 --> 00:01:28,729
要查找有关特定操作历史记录的信息，请执行以下操作
to find on particular operation history

34
00:01:28,729 --> 00:01:31,429
所以我们一直在谈论的事情
so always the thing we're talking about

35
00:01:31,429 --> 00:01:34,880
哦，我们观察到你知道一系列
is oh we observed you know a sequence of

36
00:01:34,880 --> 00:01:36,859
客户的请求，然后他们得到了
requests by clients and then they got

37
00:01:36,859 --> 00:01:39,139
在不同时间的一些反应和
some responses at different times and

38
00:01:39,139 --> 00:01:41,240
他们要的是不同的你
they asked for different different you

39
00:01:41,240 --> 00:01:44,179
知道读取不同的数据并获得
know to read different data and got

40
00:01:44,179 --> 00:01:46,549
不同的答案，你知道的是
various answers back you know is that

41
00:01:46,549 --> 00:01:50,380
我们看到的历史是可以线性化的，所以
history that we saw linearizable ok so

42
00:01:50,380 --> 00:01:53,299
这里有一个历史的例子，
here's an example of a history that

43
00:01:53,299 --> 00:01:55,969
可能被线性化，也可能不被线性化
might or might not be linearized able so

44
00:01:55,969 --> 00:01:57,770
让我们假设在某个时间点
let's suppose at some point in time some

45
00:01:57,770 --> 00:01:59,840
客户群的时间将转移到
client groups of times gonna move to the

46
00:01:59,840 --> 00:02:02,060
右边这条竖线表示时间
right this vertical bar marks the time

47
00:02:02,060 --> 00:02:05,929
在那里一个客户发送了一个请求，我是
at which a client sent a request I'm

48
00:02:05,929 --> 00:02:08,780
我要用这个符号来表示
gonna use this notation to mean that the

49
00:02:08,780 --> 00:02:12,430
请求为写入，并请求设置
request is a write and asks to set

50
00:02:12,430 --> 00:02:17,980
变量或键或任何x2值%0
variable or key or whatever x2 value 0

51
00:02:17,980 --> 00:02:20,659
所以这可以说是一个键和一个值
so sort of a key and a value this would

52
00:02:20,659 --> 00:02:23,689
对应于关键字X的PUT且为零
correspond to a put of key X and by zero

53
00:02:23,689 --> 00:02:28,370
在实验室3，然后这是某种意义上的我们
in lab 3 and then this is sort of we're

54
00:02:28,370 --> 00:02:29,780
监视客户端向客户端发送的内容
watching what the client send the client

55
00:02:29,780 --> 00:02:32,629
将此请求发送到我们的服务，并在
sent this request to our service and at

56
00:02:32,629 --> 00:02:34,670
在某一点上，该服务做出了响应，
some point the service responded and

57
00:02:34,670 --> 00:02:37,159
说，是的，你是对的，所以完成了
said yes you're right is completed so

58
00:02:37,159 --> 00:02:38,510
我们承担的是一种性质的服务
we're assuming the services of a nature

59
00:02:38,510 --> 00:02:40,459
它实际上会告诉您何时写入
that actually tells you when the write

60
00:02:40,459 --> 00:02:43,879
完成，否则定义不是
completes otherwise the definition isn't

61
00:02:43,879 --> 00:02:46,069
非常有用，好的，所以我们有这个要求
very useful ok so we have this request

62
00:02:46,069 --> 00:02:49,939
有人来写，然后我就
by somebody to write and then I'm

63
00:02:49,939 --> 00:02:51,560
想象一下在这个例子中有
imagining in this example there's

64
00:02:51,560 --> 00:02:54,769
另一个要求是因为我要
another request that because I'm putting

65
00:02:54,769 --> 00:02:56,269
这里的这个标记表示第二个
this mark here this means the second

66
00:02:56,269 --> 00:02:59,689
在第一个请求之后启动的请求
request started after the first request

67
00:02:59,689 --> 00:03:01,969
做完了，你知道为什么
finished and and you know reason why

68
00:03:01,969 --> 00:03:04,760
这一点很重要，因为这条规则
that's important is because of this rule

69
00:03:04,760 --> 00:03:07,370
可线性化的历史必须与
that linearizable history must match

70
00:03:07,370 --> 00:03:10,129
实时，而这真正的意思是
real time and what that really means is

71
00:03:10,129 --> 00:03:12,349
这些请求实际上是已知的
that requests that are known in real

72
00:03:12,349 --> 00:03:15,379
是时候在另一些事情之后开始了
time to have started after some other

73
00:03:15,379 --> 00:03:18,799
请求已完成第二个请求具有
request finished the second request has

74
00:03:18,799 --> 00:03:20,569
中的第一个请求之后发生
to occur after the first request in

75
00:03:20,569 --> 00:03:22,879
不管我们订出什么顺序，那都是
whatever order we work out that's the

76
00:03:22,879 --> 00:03:24,469
证明历史是线性化的
proof that the history was a linearized

77
00:03:24,469 --> 00:03:27,079
将可用的OK线性化，这样就可以了
linearize available ok so in this

78
00:03:27,079 --> 00:03:29,000
举个例子，我在想，还有另一个
example I'm imagining there's another

79
00:03:29,000 --> 00:03:31,909
要求写X的请求有
request that asks to write X to have

80
00:03:31,909 --> 00:03:36,530
值1，然后是并发请求
value 1 and then a concurrent request

81
00:03:36,530 --> 00:03:39,650
可能会晚一点开始，因为
may be started a little bit later as to

82
00:03:39,650 --> 00:03:44,329
把X设为2我说现在我们有两个可能
set X to 2 I said now we have two maybe

83
00:03:44,329 --> 00:03:46,069
两个不同的客户端在以下位置发出请求
two different clients issued requests at

84
00:03:46,069 --> 00:03:47,750
将X设置为2的时间大致相同
about the same time to set X to two

85
00:03:47,750 --> 00:03:49,549
不同的价值观，所以我们当然
different values so of course we're

86
00:03:49,549 --> 00:03:51,890
想知道哪一个会是
wondering which one is going to be the

87
00:03:51,890 --> 00:03:54,890
真正的价值，然后我们也有一些
real value and then we also have some

88
00:03:54,890 --> 00:04:01,239
如果你所有的东西都写得很好，那就去读吧
reads if all you have is writes well

89
00:04:01,450 --> 00:04:04,010
好吧，你说对了，所以这很难
well you have us right so it's it's hard

90
00:04:04,010 --> 00:04:05,659
对可线性化说得太多了
to say too much about linearizable

91
00:04:05,659 --> 00:04:07,370
线性化能力，因为你不知道
linearize ability because you don't know

92
00:04:07,370 --> 00:04:10,849
你没有任何证据证明这个系统
you don't have any proof that the system

93
00:04:10,849 --> 00:04:12,620
实际上做了什么或者透露了什么
actually did anything or revealed any

94
00:04:12,620 --> 00:04:17,839
值，所以我们真的需要阅读，所以让我们
values so we really need reads so let's

95
00:04:17,839 --> 00:04:21,048
想象一下我们有一些读物，除非你
imagine we have some read unless you'll

96
00:04:21,048 --> 00:04:23,290
在历史上看到我们的
be seeing our in the history

97
00:04:23,290 --> 00:04:27,070
一位客户说要在这个时候阅读
that a client said to read at this time

98
00:04:27,070 --> 00:04:30,010
第二次它得到的答案是
and the second time it got an answer for

99
00:04:30,010 --> 00:04:34,300
红键重音对SO有价值
red key accent got value to so

100
00:04:34,300 --> 00:04:37,450
大概真的看到了这个价值，
presumably actually saw this value and

101
00:04:37,450 --> 00:04:39,100
然后又有了另一个请求，可能是
then there was another request by maybe

102
00:04:39,100 --> 00:04:40,390
相同的客户端或不同的客户端
the same client or a different client

103
00:04:40,390 --> 00:04:43,060
但已知是在之后的时间里开始的
but known to have started in time after

104
00:04:43,060 --> 00:04:46,270
此请求已完成，X的此读取
this request finished and this read of X

105
00:04:46,270 --> 00:04:50,980
获得了价值，所以问题是
got value while and so the question in

106
00:04:50,980 --> 00:04:52,900
摆在我们面前的是这段历史
front of us is is this history

107
00:04:52,900 --> 00:04:55,300
可线性化，有两种
linearizable and there's sort of two

108
00:04:55,300 --> 00:04:58,450
我们可以采取的策略我们也可以
strategies we can take we can either

109
00:04:58,450 --> 00:05:00,820
编造一个序列是因为如果我们能
cook up a sequence because if we can

110
00:05:00,820 --> 00:05:03,700
想出这五个人的总共顺序
come up with a total order of these five

111
00:05:03,700 --> 00:05:06,790
符合实时和实时要求的操作
operations that obeys real time and in

112
00:05:06,790 --> 00:05:09,400
每次读取都会看到写入的值
which each read sees the value written

113
00:05:09,400 --> 00:05:12,400
由牧师主持，最近一次进行
by the priest most recently proceeding

114
00:05:12,400 --> 00:05:13,690
如果我们能赶上来的话就按顺序进行
right in the order if we can come up

115
00:05:13,690 --> 00:05:15,490
有了这个订单，那就证明了
with that order then that's a proof the

116
00:05:15,490 --> 00:05:17,770
历史是可以线性化的另一种策略
history is linearizable another strategy

117
00:05:17,770 --> 00:05:23,140
就是观察这些规则每一条
is to observe that these rules each one

118
00:05:23,140 --> 00:05:26,730
可能暗示这件事发生在那之前
may imply certain this comes before that

119
00:05:26,730 --> 00:05:29,800
图中的边，如果我们能找到一个
edges in a graph and if we can find a

120
00:05:29,800 --> 00:05:32,140
此操作中的循环必须早于
cycle in this operation must come before

121
00:05:32,140 --> 00:05:33,970
我们可以在那次行动中找到一个心理医生
that operation we can find a psych on

122
00:05:33,970 --> 00:05:35,980
这张图证明了
that graph and that's proof that the

123
00:05:35,980 --> 00:05:39,040
历史是不能线性化的
history isn't linearizable and for small

124
00:05:39,040 --> 00:05:40,240
历史上我们也许真的能够
histories we may actually be able to

125
00:05:40,240 --> 00:05:42,280
列举每一单订单和使用
enumerate every single order and use

126
00:05:42,280 --> 00:05:45,550
这表明这段历史并不是
that show this history isn't

127
00:05:45,550 --> 00:05:51,280
不管怎样都可以线性化任何想法
linearizable anyway any any any thoughts

128
00:05:51,280 --> 00:05:53,980
关于这是否可能是或可能不是
about whether this might be or might not

129
00:05:53,980 --> 00:05:56,730
是可线性化的
be linearizable

130
00:06:00,410 --> 00:06:03,130
是
yes

131
00:06:08,330 --> 00:06:11,330
是的，好的，那么观察结果是，嗯
yes okay so the observation is that um

132
00:06:11,330 --> 00:06:15,560
我们看到有一点麻烦
it's a little bit troubling that we saw

133
00:06:15,560 --> 00:06:17,330
使用Iu读取-然后使用读取
read with IU - and then the read with

134
00:06:17,330 --> 00:06:21,099
想要价值，也许这是矛盾的
value want and maybe that contradicts

135
00:06:21,099 --> 00:06:23,210
你知道有两种权利，一种是
you know there were two rights one with

136
00:06:23,210 --> 00:06:25,490
一对一的价值-所以我们
value one on one value - so that so we

137
00:06:25,490 --> 00:06:26,840
当然，如果我们必须带着价值去阅读
certainly if we had to read with value

138
00:06:26,840 --> 00:06:28,970
三个，这显然会是一件很重要的事情
three that would obviously be something

139
00:06:28,970 --> 00:06:31,159
我大错特错了，你知道的，但是我们
I got terribly wrong you know but we got

140
00:06:31,159 --> 00:06:32,720
两人中有一人的权利和一人的权利
there were a right of one in two and a

141
00:06:32,720 --> 00:06:34,849
读一读和二读，所以问题是
read of one and two so the question is

142
00:06:34,849 --> 00:06:36,470
此读取顺序是否可以
whether this order of reads could

143
00:06:36,470 --> 00:06:39,349
可能会和解的方式
possibly be reconciled with the way

144
00:06:39,349 --> 00:06:43,030
这两项权利在历史上都有体现。
these two rights show up in the history

145
00:06:59,289 --> 00:07:04,580
好的，所以我是什么，我是什么，我们是什么游戏
okay so what I'm what I'm the game we're

146
00:07:04,580 --> 00:07:07,520
打球就是我们有大概两个
playing is that we have a like maybe two

147
00:07:07,520 --> 00:07:08,960
客户或三个客户，他们是
clients or three clients and they're

148
00:07:08,960 --> 00:07:10,789
谈论一些你知道的服务，也许是
talking some service you know maybe a

149
00:07:10,789 --> 00:07:12,710
去年木筏上的一些东西和我们是什么
raft last year something and what we are

150
00:07:12,710 --> 00:07:15,529
查看请求和响应是正确的
seeing is requests and responses right

151
00:07:15,529 --> 00:07:18,259
所以这意味着我们看到
so what this means is that we saw

152
00:07:18,259 --> 00:07:21,680
来自客户端的将X写入
requests from a client to write X to the

153
00:07:21,680 --> 00:07:23,539
你知道，把X和1的请求放在一起
you know put requests for X and one and

154
00:07:23,539 --> 00:07:25,219
我们看到了这里的回应，所以我们所知道的
we saw the response here so what we know

155
00:07:25,219 --> 00:07:27,289
是不是在这段时间的某个地方
is that somewhere during this interval

156
00:07:27,289 --> 00:07:29,319
时间的长短，大概这项服务实际上
of time presumably the service actually

157
00:07:29,319 --> 00:07:32,210
在内部更改x-1的值并
internally change the value of x - 1 and

158
00:07:32,210 --> 00:07:34,610
这意味着在某个地方
what this means is that somewhere in

159
00:07:34,610 --> 00:07:38,919
在此时间间隔内，服务
this interval of time the service

160
00:07:38,919 --> 00:07:42,590
可能改变了它内部的想法
presumably changed its internal idea of

161
00:07:42,590 --> 00:07:44,150
x-2的值在这里的某个位置
the value of x - 2 somewhere in this

162
00:07:44,150 --> 00:07:47,029
时间，但你知道，它只是在某个地方
time but you know it's just somewhere in

163
00:07:47,029 --> 00:07:48,889
这一次并不意味着它发生了
this time it doesn't mean it happened

164
00:07:48,889 --> 00:07:52,250
在这里还是在这里回答你的问题
here or here does that answer your

165
00:07:52,250 --> 00:07:53,590
问题
question

166
00:07:53,590 --> 00:07:56,590
是
yes

167
00:08:07,889 --> 00:08:10,620
是的，好的，那么观察是这样的
yes okay so the observation is that is

168
00:08:10,620 --> 00:08:13,500
是可以线性化的，而且它一直伴随着
linearizable and it's been accompanied

169
00:08:13,500 --> 00:08:15,689
通过线性化的实际证明
by an actual proof of the linearize

170
00:08:15,689 --> 00:08:17,490
能力，也就是一种能力的展示
ability namely a demonstration of the

171
00:08:17,490 --> 00:08:19,979
表明它是可线性化的阶数
order that shows that it is linearizable

172
00:08:19,979 --> 00:08:25,259
顺序是，是的，它是可线性化的
and the order is yes it's linearizable

173
00:08:25,259 --> 00:08:32,070
并且顺序是X的第一个右边，带有
and the order is first right of X with

174
00:08:32,070 --> 00:08:36,929
值0，并且服务器同时获得这两个
value 0 and the server got both of these

175
00:08:36,929 --> 00:08:38,490
权利大致在同一时间
rights at roughly the same time it's

176
00:08:38,490 --> 00:08:40,529
仍然不得不选择所有的顺序本身
still had to choose the order itself all

177
00:08:40,529 --> 00:08:43,140
好的，这么说吧，它可能
right so let's just say it could have

178
00:08:43,140 --> 00:08:45,890
先执行x2值%2的右侧
executed the right of x2 value 2 first

179
00:08:45,890 --> 00:08:54,089
然后读取X，然后执行
and then the read of X then executed the

180
00:08:54,089 --> 00:08:58,589
读到X，第一次读到的会是哪一个
read of X which would the first read of

181
00:08:58,589 --> 00:09:01,230
X，在这一点上将产生2和
X which at that point would yield 2 and

182
00:09:01,230 --> 00:09:03,450
然后我们会说下一次行动
then we're gonna say the next operation

183
00:09:03,450 --> 00:09:05,040
已执行，则是X对1的权利
had executed it was the right of X to 1

184
00:09:05,040 --> 00:09:08,430
中的最后一个操作
and then the last operation in the

185
00:09:08,430 --> 00:09:16,260
历史是从X到1的读数，因此
history is the read of X to 1 and so

186
00:09:16,260 --> 00:09:17,670
这证明了历史是
this is proof that the history is

187
00:09:17,670 --> 00:09:19,430
可以线性化，因为这里有一个顺序
linearizable because here's an order

188
00:09:19,430 --> 00:09:22,350
这是整个行动的顺序
it's a total order of the operations and

189
00:09:22,350 --> 00:09:24,810
这是它实时匹配的顺序
this is the order it matches real time

190
00:09:24,810 --> 00:09:29,310
所以这意味着我们走吧
so what that means is well just go

191
00:09:29,310 --> 00:09:31,170
通过它，X到0的权利就来了
through it the the right of X to 0 comes

192
00:09:31,170 --> 00:09:32,339
首先，这完全是
first and that's that's totally

193
00:09:32,339 --> 00:09:33,660
很直观，因为它实际上已经完成了
intuitive since it's actually finished

194
00:09:33,660 --> 00:09:37,560
在任何其他操作开始之前，
before any other operations started the

195
00:09:37,560 --> 00:09:40,320
X对1的权利来了抱歉
right of X to 1 comes sorry the rate of

196
00:09:40,320 --> 00:09:42,060
X到2排在第二位，所以我们要说
X to 2 comes second so we're gonna say

197
00:09:42,060 --> 00:09:46,920
也许我会在这里做这样的标记
maybe that I'm gonna mark here that sort

198
00:09:46,920 --> 00:09:48,839
我们想象这些的实时时间
of real time at which we imagine these

199
00:09:48,839 --> 00:09:50,699
行动恰好证明了
operations happen to demonstrate that

200
00:09:50,699 --> 00:09:52,800
这里的订单是实时匹配的，所以
the order here does match real time so

201
00:09:52,800 --> 00:09:54,300
它会说我会在这里写一个大X
it'll say I'll just write a big X here

202
00:09:54,300 --> 00:09:56,220
来纪念我们想象这一切的时间
to mark the time when we imagine this

203
00:09:56,220 --> 00:09:59,160
手术发生得很好，所以那是
operation happened all right so that's

204
00:09:59,160 --> 00:10:01,949
第二次手术之后我们就
the second operation then we're

205
00:10:01,949 --> 00:10:03,720
假设下一个操作是
imagining that the next operation is the

206
00:10:03,720 --> 00:10:07,380
读过X of 2 We，你知道没有
read of X of 2 we you know there's no

207
00:10:07,380 --> 00:10:08,820
因为读取X而导致的实时性问题
real time problem because the read of X

208
00:10:08,820 --> 00:10:11,070
2的实际上是这个u同时发生的吗？
of 2 actually was this u concurrently

209
00:10:11,070 --> 00:10:13,079
有了2的X的右边，你就知道它是
with the right of X of 2 you know it's

210
00:10:13,079 --> 00:10:14,640
不像X的权利，也不像X的读法
not like the right of X the read of X of

211
00:10:14,640 --> 00:10:16,110
2做完了，然后才做了正确的事
2 finished and only then did the right

212
00:10:16,110 --> 00:10:18,660
X的权利，X的权利，从那里开始
of X right of X with to start there

213
00:10:18,660 --> 00:10:20,069
真的是同时发生的，我们可以想象一下
really are concurrent we'll just imagine

214
00:10:20,069 --> 00:10:21,240
那就是说
that that

215
00:10:21,240 --> 00:10:23,519
在这个时间点上
sort of point in time at which this

216
00:10:23,519 --> 00:10:25,230
发生的手术就在那里，所以
operation happened is right there so

217
00:10:25,230 --> 00:10:27,449
这就是你知道我们不在乎什么时候
this is the you know we don't care when

218
00:10:27,449 --> 00:10:28,589
这件事发生了，这么说吧
this one happened let's just say there's

219
00:10:28,589 --> 00:10:33,269
第一次行动，第二次，第三次现在我们
the first operation second third now we

220
00:10:33,269 --> 00:10:36,660
我只想说，我有X的权利
have a right of X of one let's just say

221
00:10:36,660 --> 00:10:39,089
它在这里实时发生，只是必须
it happens here in real time just has to

222
00:10:39,089 --> 00:10:42,779
在发生的操作之后发生
happen after the operations that occur

223
00:10:42,779 --> 00:10:43,949
在它之前的顺序，所以这将是说
before it in the order so that will say

224
00:10:43,949 --> 00:10:45,600
有第四次手术，现在我们
there's the fourth operation and now we

225
00:10:45,600 --> 00:10:47,009
有x1的读数，它可以很漂亮
have the read of x1 and it can pretty

226
00:10:47,009 --> 00:10:48,929
任何时候都会发生很多事情，但让我们直说吧
much happen at any time but let's say it

227
00:10:48,929 --> 00:10:52,439
在这里发生，好的，所以这是
happens here okay so this is the

228
00:10:52,439 --> 00:10:52,889
钻石
Diamonds

229
00:10:52,889 --> 00:10:54,360
所以我们有一个订单，这是
so we have the order this is the

230
00:10:54,360 --> 00:10:56,369
证明该命令是
demonstration that the order is

231
00:10:56,369 --> 00:10:58,259
与实时一致，那就是我们可以
consistent with real time that is we can

232
00:10:58,259 --> 00:11:00,089
为每个操作选择一个时间
pick a time for each of the operations

233
00:11:00,089 --> 00:11:02,850
这是在它的开始和结束时间内
that's within its start and end time

234
00:11:02,850 --> 00:11:06,600
这将导致这一总订单
that would cause this total order to

235
00:11:06,600 --> 00:11:08,910
与我们的实时顺序相匹配，因此
match our real time order and so the

236
00:11:08,910 --> 00:11:12,269
最后一个问题是，每个人都看过
final question is did each read see the

237
00:11:12,269 --> 00:11:14,249
价值由最密切的
value written by the most closely

238
00:11:14,249 --> 00:11:16,939
同一变量的前一权利，因此
preceding right of the same variable so

239
00:11:16,939 --> 00:11:20,189
这个读数前面有两个V
there's two V's this read preceded by a

240
00:11:20,189 --> 00:11:21,899
正确的值，所以这是
right with that correct value so that's

241
00:11:21,899 --> 00:11:23,550
很好，这个阅读之前有一个
good and this read is preceded by a

242
00:11:23,550 --> 00:11:26,549
最接近的右边前面有一个右边
right most closely preceded by a right

243
00:11:26,549 --> 00:11:32,670
同样的值也可以，所以这个就是这个
of the same value also okay so this this

244
00:11:32,670 --> 00:11:34,649
证明了这段历史是
is a demonstration that this history was

245
00:11:34,649 --> 00:11:39,089
可线性化，你知道的，你知道的
linearizable and you know the you know

246
00:11:39,089 --> 00:11:40,769
这要看你当时是怎么想的
depends on what you thought when you

247
00:11:40,769 --> 00:11:42,990
第一次看到历史，但它不是
first saw the history but it's not

248
00:11:42,990 --> 00:11:44,819
始终立即清除该设置
always immediately clear that set up

249
00:11:44,819 --> 00:11:47,490
这很复杂，你知道这很容易
this complicated is you know it's easy

250
00:11:47,490 --> 00:11:50,429
当你看着这些的时候，你会上当受骗
to be tricked when looking at these

251
00:11:50,429 --> 00:11:51,540
你认为哪段历史哦
histories which do you think oh the

252
00:11:51,540 --> 00:11:53,699
先从x1的右边开始，所以我们只是
right of x1 started first so we just

253
00:11:53,699 --> 00:11:56,069
在某种程度上假设第一个值
sort of assumed that the first value

254
00:11:56,069 --> 00:11:57,689
写的肯定是一个，但那实际上是
written must be one but that's actually

255
00:11:57,689 --> 00:12:03,540
这里不是必需的，关于以下方面的任何问题
not required here any questions about

256
00:12:03,540 --> 00:12:05,779
这
this

257
00:12:15,089 --> 00:12:18,239
如果你是说如果这两个人
if the you mean if these two were moved

258
00:12:18,239 --> 00:12:23,219
像这样没问题，所以如果这样的话
like this the okay so if if if this if

259
00:12:23,219 --> 00:12:26,099
仅颁发了具有价值的权利
the right with value to was only issued

260
00:12:26,099 --> 00:12:30,329
由客户在读完口音后
by the client after the read of accent

261
00:12:30,329 --> 00:12:33,779
返回的值不会是
value to returned that wouldn't be

262
00:12:33,779 --> 00:12:37,319
可线性化，因为无论按什么顺序
linearizable because in whatever order

263
00:12:37,319 --> 00:12:39,089
你知道我们拿出的任何订单都有
you know any order we come up with has

264
00:12:39,089 --> 00:12:41,129
遵守实时命令，所以任何
to obey the real-time ordering so any

265
00:12:41,129 --> 00:12:42,629
我们想出的命令将不得不
order we come up with would have had to

266
00:12:42,629 --> 00:12:46,289
把读X放在…之前
have the read of X with to precede the

267
00:12:46,289 --> 00:12:48,899
X的右边有2，因为没有
right of X with 2 and since there's no

268
00:12:48,899 --> 00:12:52,799
这里的X/2洞察力的其他权利
other right of X of 2 insight here that

269
00:12:52,799 --> 00:12:55,079
意味着此时的读取可能
means that a read at this point could

270
00:12:55,079 --> 00:12:57,029
只能看到0或1，因为它们是
only see 0 or 1 because those are the

271
00:12:57,029 --> 00:12:59,549
只有其他两项权利可能
only other 2 rights that could possibly

272
00:12:59,549 --> 00:13:03,329
在这之前读一读是如此感人，你知道吗？
come before this read so moving you know

273
00:13:03,329 --> 00:13:06,089
把这些移开那么多就会
shifting these that much makes the would

274
00:13:06,089 --> 00:13:10,459
使示例不可线性化
make the example not linearizable

275
00:13:19,090 --> 00:13:22,090
是
yes

276
00:13:24,670 --> 00:13:27,260
我是说第一条垂直线
I'm saying that the first vertical line

277
00:13:27,260 --> 00:13:29,690
是客户端将
is the moment the client sends the

278
00:13:29,690 --> 00:13:32,360
请求，第二条垂直线是
request and the second vertical line is

279
00:13:32,360 --> 00:13:34,130
当客户端收到
the moment the client receives the

280
00:13:34,130 --> 00:13:39,560
请求，是的，是的，所以这是一个非常
request yes yeah yeah so this is a very

281
00:13:39,560 --> 00:13:42,890
以客户为中心的定义
client centric kind of definition it

282
00:13:42,890 --> 00:13:44,540
他说你知道客户应该看看
says you know clients should see the

283
00:13:44,540 --> 00:13:46,580
遵循行为和发生的事情
following behavior and what happens

284
00:13:46,580 --> 00:13:48,380
在我们发出请求之后，也许会有
after us send a request in maybe there's

285
00:13:48,380 --> 00:13:49,970
很多复制品可能会很复杂
a lot of replicas maybe a complicated

286
00:13:49,970 --> 00:13:51,740
网络谁知道它几乎什么都没有
network who knows what it's almost none

287
00:13:51,740 --> 00:13:53,570
在我们的业务中，我们只是
of our business we're only the

288
00:13:53,570 --> 00:13:56,180
定义仅涉及哪些客户端
definition is only about what clients

289
00:13:56,180 --> 00:13:59,240
看，这里有一些灰色区域，我们将
see there's some gray areas which we'll

290
00:13:59,240 --> 00:14:01,040
很快就会苏醒过来，就像客户
come to in a moment like if the client

291
00:14:01,040 --> 00:14:03,920
那么应该需要重新传输请求
should need to retransmit a request then

292
00:14:03,920 --> 00:14:05,630
我们还得让你知道这是
we also have to you know that's

293
00:14:05,630 --> 00:14:12,680
一些我们必须考虑的事情，好的，所以
something we have to think about okay so

294
00:14:12,680 --> 00:14:16,400
这个是可线性化的，这里是另一个
this one is linearizable here's another

295
00:14:16,400 --> 00:14:19,700
例如，我实际上要从
example I'm actually going to start out

296
00:14:19,700 --> 00:14:22,400
因为它几乎一模一样，所以我要
with it being almost identical I'm gonna

297
00:14:22,400 --> 00:14:23,450
开始的时候，你和我是一模一样的
start out with you being identical for

298
00:14:23,450 --> 00:14:25,100
第一个示例，同样，我们有一个
the first example so again we have a

299
00:14:25,100 --> 00:14:28,460
X的右边有0，我们有这两个
right of X with 0 we have these two

300
00:14:28,460 --> 00:14:38,150
同时拥有的权利和我们拥有的相同权利
concurrent rights and we have the same

301
00:14:38,150 --> 00:14:52,820
到目前为止完全相同的两个读数
two reads those are so far identical to

302
00:14:52,820 --> 00:14:54,530
上一个示例因此我们
the previous example so therefore we

303
00:14:54,530 --> 00:14:56,090
知道这一定是这件事一定是这件事
know this must be this alone must be

304
00:14:56,090 --> 00:14:58,250
最小化，但我要添加，让我们
minimal but I'm going to add let's let's

305
00:14:58,250 --> 00:15:02,420
假设客户端1发出了这两个命令
imagine that client 1 issued these two

306
00:15:02,420 --> 00:15:04,310
请求的定义实际上并不是
requests the definition doesn't really

307
00:15:04,310 --> 00:15:06,230
关心客户，而不是她自己的理智
care about clients but her own sanity

308
00:15:06,230 --> 00:15:08,570
将假设客户端1为红色X，并看到两个
will assume client 1 red X and saw two

309
00:15:08,570 --> 00:15:11,450
后来又红了X，看到了一个，但是
and then later red X and saw one but

310
00:15:11,450 --> 00:15:13,880
到目前为止没问题，我说还有另一个
that's okay so far I say there's another

311
00:15:13,880 --> 00:15:17,630
客户端和另一个客户端执行读取
client and the other client does a read

312
00:15:17,630 --> 00:15:23,090
它会看到一个1，然后是另一个
of X and it sees a 1 and then the other

313
00:15:23,090 --> 00:15:25,700
客户端是X的第二次读取，它看到
client is a second read of X and it sees

314
00:15:25,700 --> 00:15:31,280
-所以这是可线性化的，我们要么
- so this is linearizable and we either

315
00:15:31,280 --> 00:15:33,260
必须拿出一份订单
have to come up with an order

316
00:15:33,260 --> 00:15:39,890
或者这出现在具有以下特征的图表之前
or this comes before that graph that has

317
00:15:39,890 --> 00:15:42,460
其中的一个循环
a cycle in it

318
00:15:50,210 --> 00:15:54,410
所以你知道这件事
so you know that thing this is getting

319
00:15:54,410 --> 00:15:57,110
问题是如果一个客户看到
at the puzzle is if one client saw

320
00:15:57,110 --> 00:15:59,990
这里只有两个权利所以他们会让你
there's only two rights here so they you

321
00:15:59,990 --> 00:16:01,700
以任何顺序或其中一项权利知道
know in any order or one of the rights

322
00:16:01,700 --> 00:16:03,320
要么先来，要么另一种速度
comes first or the other rate comes

323
00:16:03,320 --> 00:16:08,089
第一个也是第一个直观的客户端1
first and intuitively client one

324
00:16:08,089 --> 00:16:10,370
观察到具有值为
observed that the right with value to

325
00:16:10,370 --> 00:16:14,870
先来后来的是价值权
came first and then the right of value

326
00:16:14,870 --> 00:16:19,010
一对这两个读数意味着
one right these two reads mean that has

327
00:16:19,010 --> 00:16:21,560
情况是这样的，在任何法律命令中
to be the case that in any legal order

328
00:16:21,560 --> 00:16:23,000
两个人的权利必须出现在
of the right of two has to come before

329
00:16:23,000 --> 00:16:25,190
一个人的右边，以便攀登
the right of one in order for the climb

330
00:16:25,190 --> 00:16:27,580
什么时候看过这个，它是一样的
when to have seen this and it's the same

331
00:16:27,580 --> 00:16:31,100
我们在这里看到的顺序是对称的
order we saw over here but symmetrically

332
00:16:31,100 --> 00:16:33,830
客户一的经历清楚地表明
client one's experience clearly shows

333
00:16:33,830 --> 00:16:39,070
对面的右边对不起，嗯，好的
the opposite right sorry huh fine to

334
00:16:39,070 --> 00:16:41,209
客户的经历正好相反
client who's experience was the opposite

335
00:16:41,209 --> 00:16:44,209
客户先看到一个人的权利
clients to saw the right of one first

336
00:16:44,209 --> 00:16:47,800
然后是有价值的右派
and then the right with value too and

337
00:16:47,800 --> 00:16:52,040
这里的规则之一是
one of the rules here is that there's

338
00:16:52,040 --> 00:16:56,089
只有一个操作的总顺序不是
just one total order of operations not

339
00:16:56,089 --> 00:16:58,130
允许不同的客户端查看
allowed to have different clients see

340
00:16:58,130 --> 00:17:00,910
不同的历史或不同的
different histories or different

341
00:17:00,910 --> 00:17:03,680
不同的进化论和进化论
different progressions evolutions of the

342
00:17:03,680 --> 00:17:05,420
存储在系统中的值
values that are stored in the system

343
00:17:05,420 --> 00:17:07,069
总共只能有一个订单
there can only be one total of order

344
00:17:07,069 --> 00:17:09,970
所有客户都必须体验的
that all clients have to experience

345
00:17:09,970 --> 00:17:11,809
操作，这些操作与
operations that are consistent with the

346
00:17:11,809 --> 00:17:16,280
一份订单，如果是这一个客户
one order and if one this one client

347
00:17:16,280 --> 00:17:18,319
很明显地暗示这个顺序是正确的
clearly implies that the order is right

348
00:17:18,319 --> 00:17:21,050
-然后是右边的，所以我们应该
- and then right one and so we should

349
00:17:21,050 --> 00:17:23,720
不能有任何其他客户
not be able to have any other client who

350
00:17:23,720 --> 00:17:25,790
观察到该订单是
observes proof that the order was

351
00:17:25,790 --> 00:17:29,559
还有什么是我们这里有的吗？
anything else which is what we have here

352
00:17:29,559 --> 00:17:34,390
所以这有点直观
and so that's a bit of a intuitive

353
00:17:34,390 --> 00:17:37,370
对这里出了什么问题的解释
explanation for what's going wrong here

354
00:17:37,370 --> 00:17:38,900
顺便说一句，之所以会这样
and and by the way the reason why this

355
00:17:38,900 --> 00:17:41,300
可能会出现在我们的系统中
could come up in the systems that we

356
00:17:41,300 --> 00:17:43,429
就是我们正在建造的
build and look at is that we're building

357
00:17:43,429 --> 00:17:46,070
复制的系统您可能知道RAFT
replicated systems either you know raft

358
00:17:46,070 --> 00:17:48,860
复制副本或可能具有缓存的系统
replicas or maybe systems with caching

359
00:17:48,860 --> 00:17:50,300
但我们正在建立的系统
in them but we're building systems that

360
00:17:50,300 --> 00:17:52,220
有许多数据副本，因此
have many copies of the data and so

361
00:17:52,220 --> 00:17:54,950
可能有许多服务器具有以下副本
there may be many servers with copies of

362
00:17:54,950 --> 00:17:57,679
它们中的X可能具有不同的值
X in them possibly with different values

363
00:17:57,679 --> 00:17:59,210
在不同的时间，如果他们没有
at different times right if they haven't

364
00:17:59,210 --> 00:18:01,190
还没拿到承诺还是什么的
gotten the commits yet or something some

365
00:18:01,190 --> 00:18:03,470
复制副本可能有一个值，某些值可能是
replicas may have one value some may of

366
00:18:03,470 --> 00:18:03,860
另一个
the other

367
00:18:03,860 --> 00:18:07,070
但尽管如此，如果我们的系统
but in spite of that if our system is

368
00:18:07,070 --> 00:18:09,440
可线性化或强一致性
linearizable or strongly consistent it

369
00:18:09,440 --> 00:18:13,130
必须表现得好像只有一个
must behave as if there was only one

370
00:18:13,130 --> 00:18:16,460
数据副本和一个线性序列
copy of the data and one linear sequence

371
00:18:16,460 --> 00:18:18,740
应用于数据的操作的
of operations applied to the data that's

372
00:18:18,740 --> 00:18:20,420
为什么这是一个有趣的例子
why this is an interesting example

373
00:18:20,420 --> 00:18:22,660
因为这可能会在某种程度上出现
because this could come up in a sort of

374
00:18:22,660 --> 00:18:25,010
有两个副本的Buggy系统
buggy system that had two copies of the

375
00:18:25,010 --> 00:18:27,260
数据和一份拷贝执行这些权利
data and one copy executed these rights

376
00:18:27,260 --> 00:18:28,760
一种顺序，另一种复制品
in one order and the other replicas

377
00:18:28,760 --> 00:18:30,320
执行了其他订单中的权利
executed the rights in the other order

378
00:18:30,320 --> 00:18:32,570
然后我们可以看到这个并将其线性化
and then we could see this and linearize

379
00:18:32,570 --> 00:18:34,880
能力说不，我们看不到我们是
ability says no we can't see that we're

380
00:18:34,880 --> 00:18:35,929
不允许在正确的
not allowed to see that in the correct

381
00:18:35,929 --> 00:18:39,679
系统，因此图形中的循环位于
system so the the cycle in the graph in

382
00:18:39,679 --> 00:18:44,090
这张图出现在那张图之前
the this comes before that graph that

383
00:18:44,090 --> 00:18:45,799
将会是一种稍微多一点的证据
would be a sort of slightly more proof e

384
00:18:45,799 --> 00:18:47,660
这不可线性化的证据是
proof that this is not linearizable is

385
00:18:47,660 --> 00:18:51,260
两个人的权利必须先于
that the right of two has to come before

386
00:18:51,260 --> 00:18:55,340
客户一读到两个，所以有一个
client ones read of two so there's one

387
00:18:55,340 --> 00:18:59,210
像这样的箭头，所以这个右边必须
arrow like this so this right has to

388
00:18:59,210 --> 00:19:05,260
出现在读取客户端读取之前
come before that read client ones read

389
00:19:05,260 --> 00:19:09,380
必须排在X的右边，带
has to come before the right of X with

390
00:19:09,380 --> 00:19:13,700
值1，否则此读取不会
value one otherwise this read wouldn't

391
00:19:13,700 --> 00:19:15,830
如果可以的话，你可以看对一个吗？
be able to see one right if this you can

392
00:19:15,830 --> 00:19:17,030
想象一下这种权利可能会发生在
imagine this right might happen very

393
00:19:17,030 --> 00:19:20,000
在订单的前面，但是在这种情况下，这是
early in the order but in that case this

394
00:19:20,000 --> 00:19:21,740
读到X就看不到它会看到的
read of X wouldn't see one it would see

395
00:19:21,740 --> 00:19:25,090
两个因为我们知道这家伙看到了两个所以
two since we know this guy saw two so

396
00:19:25,090 --> 00:19:28,900
X与2的读数必须在
the read of X with two must come before

397
00:19:28,900 --> 00:19:32,809
X的权利，其中一个是X的权利
the right of X with one the right of X

398
00:19:32,809 --> 00:19:34,580
必须在任何读取X之前出现
of one must come before any read of X

399
00:19:34,580 --> 00:19:37,190
值为1，因为包括客户端
with value 1 because including client

400
00:19:37,190 --> 00:19:42,679
谁读过值为1的X，但在
who's read of X with value 1 but in

401
00:19:42,679 --> 00:19:44,600
在这里和这里获得值1的顺序
order to get value 1 here and for this

402
00:19:44,600 --> 00:19:47,030
读一读，看看X的右边，我也是
read to see to the right of X with I too

403
00:19:47,030 --> 00:19:50,169
必须在顺序中介于
must come between in in the order

404
00:19:50,169 --> 00:19:52,820
在这两个行动之间所以我们知道
between these two operations so we know

405
00:19:52,820 --> 00:19:55,840
X1的读数必须在
that the read of X 1 must come before

406
00:19:55,840 --> 00:19:59,140
在X2的右边，这是一个循环
the right of X 2 and that's a cycle

407
00:19:59,140 --> 00:20:03,049
好的，所以没有，没有维尼
alright so there's no there's no Vinnie

408
00:20:03,049 --> 00:20:06,140
或者顺序之类的，但是没有线性的
or order or that but there's no linear

409
00:20:06,140 --> 00:20:10,130
所有这些时间都能服从的命令
order that can obey all of these time

410
00:20:10,130 --> 00:20:14,059
和价值规则，而不是因为
and value rules and there isn't because

411
00:20:14,059 --> 00:20:16,530
这里面有一个循环
there's a cycle in the

412
00:20:16,530 --> 00:20:24,480
在图表中是的
in the graph yes

413
00:20:32,870 --> 00:20:35,550
这是个很好的问题，这个这个
that's a good question this this

414
00:20:35,550 --> 00:20:37,410
定义关于的定义
definitions the definition about

415
00:20:37,410 --> 00:20:41,070
历史不一定是关于制度的
history's not about necessarily systems

416
00:20:41,070 --> 00:20:43,650
所以它没有说的是一个系统
so what it's not saying is that a system

417
00:20:43,650 --> 00:20:46,950
设计是可以线性化的，如果某些东西
design is linearizable if something

418
00:20:46,950 --> 00:20:50,460
关于设计，它真的只是
about the design it's really only

419
00:20:50,460 --> 00:20:53,580
历史就是历史，所以如果我们不能
history by history so if we don't get to

420
00:20:53,580 --> 00:20:55,710
了解系统如何在内部运行
know how the system operates internally

421
00:20:55,710 --> 00:20:57,450
我们唯一知道的就是我们可以
and the only thing we know is we get to

422
00:20:57,450 --> 00:20:59,520
在它执行的时候看着它，然后在
watch it while it executes then before

423
00:20:59,520 --> 00:21:01,130
我们看到了任何我们不知道的东西
we've seen anything we just don't know

424
00:21:01,130 --> 00:21:02,790
好的，我们的意思是，我们会假设它是
right we mean we'll assume it's

425
00:21:02,790 --> 00:21:04,470
可线性化，然后我们可以看到更多
linearizable and then we see more and

426
00:21:04,470 --> 00:21:06,810
更多操作顺序此阿卡什
more sequences of operations this Akash

427
00:21:06,810 --> 00:21:08,550
它们都与线性化一致
they're all consistent with linearize

428
00:21:08,550 --> 00:21:10,560
能力他们都遵循这些规则所以
ability they all follow these rules so

429
00:21:10,560 --> 00:21:12,570
你知道我们认为很可能是这个
you know we believe it's probably this

430
00:21:12,570 --> 00:21:14,340
不是所有的线性化，如果我们曾经
isn't linearize of all and if we ever

431
00:21:14,340 --> 00:21:15,780
看到一个不是，然后我们意识到它是
seen one that isn't then we realize it's

432
00:21:15,780 --> 00:21:20,460
不可线性化，所以这是，是的，这是
not linearizable so this is yeah it's

433
00:21:20,460 --> 00:21:22,110
不是关于系统设计的定义
not a definition on the system design

434
00:21:22,110 --> 00:21:23,880
这是一种定义，关于我们在做什么
it's a definition on what the what we

435
00:21:23,880 --> 00:21:25,530
观察系统以在此基础上执行此操作
observe the system to do so in that

436
00:21:25,530 --> 00:21:27,020
感觉上可能有一点
sense it's maybe a little bit

437
00:21:27,020 --> 00:21:28,830
如果你试图设计一个不令人满意的
unsatisfying if you're trying to design

438
00:21:28,830 --> 00:21:30,420
有些东西是对的，没有食谱
something right there's not a recipe for

439
00:21:30,420 --> 00:21:32,670
你知道你是如何设计的，除了在
how you design you know except in a

440
00:21:32,670 --> 00:21:33,960
微不足道的感觉是如果你有一个
trivial sense that if you had a single

441
00:21:33,960 --> 00:21:37,260
非常简单的系统中的服务器一台服务器
server in very simple systems one server

442
00:21:37,260 --> 00:21:40,020
数据的一份拷贝未穿线或
one copy of the data not threaded or

443
00:21:40,020 --> 00:21:42,330
多核之类的，有点
multi-core or anything it's a little bit

444
00:21:42,330 --> 00:21:43,770
很难建立一个违反
hard to build a system that violates

445
00:21:43,770 --> 00:21:46,650
这是一个非常简单的设置，但是非常棒
this in a very simple set up but super

446
00:21:46,650 --> 00:21:50,280
很容易在任何形式上违反它
easy to violate it in any kind of

447
00:21:50,280 --> 00:21:55,770
分布式系统好的，所以这一课
distributed system okay so the lesson

448
00:21:55,770 --> 00:21:59,550
从这一点来看，只有
from this is that there's only can only

449
00:21:59,550 --> 00:22:04,800
是系统所处的一个顺序
be one order in which the system is

450
00:22:04,800 --> 00:22:07,260
观察以执行全部写入
observed to execute the writes all

451
00:22:07,260 --> 00:22:10,350
客户必须看到价值是一致的
clients have to see value is consistent

452
00:22:10,350 --> 00:22:13,350
在系统执行写入的情况下
with the system executing the writes in

453
00:22:13,350 --> 00:22:16,460
同样的订单
the same order

454
00:22:18,020 --> 00:22:19,760
这是一段非常简单的历史
here's a very simple history

455
00:22:19,760 --> 00:22:24,380
另一个例子是假设我们写“使徒行传”
another example supposing we write acts

456
00:22:24,380 --> 00:22:27,500
值为1，然后确定
with value 1 and then definitely

457
00:22:27,500 --> 00:22:29,330
随后，在时间上，可能会与另一个
subsequently in time maybe with another

458
00:22:29,330 --> 00:22:32,210
客户端另一个客户端启动权限
client another client launches a right

459
00:22:32,210 --> 00:22:34,670
值为2的X的值，并看到响应
of X with value 2 and sees a response

460
00:22:34,670 --> 00:22:36,170
从仪式回来说，是的，我做了
back from the service saying yes I did

461
00:22:36,170 --> 00:22:38,540
右边，然后第三个客户端执行
the right and then a third client does a

462
00:22:38,540 --> 00:22:45,800
读了X，我就给你买了一本，所以这就是
read of X and gets got you one so this

463
00:22:45,800 --> 00:22:47,630
是一个非常简单的例子，显然不是
is a very easy example it's clearly not

464
00:22:47,630 --> 00:22:50,650
可线性化，因为时间规则意味着
linearizable because the time rule means

465
00:22:50,650 --> 00:22:54,230
唯一可能的顺序是
that the only possible order is the

466
00:22:54,230 --> 00:22:55,970
X的右边有1，X的右边是2
right of X with 1 the right of X is 2

467
00:22:55,970 --> 00:22:57,860
X的读数是1，所以它必须是
the read of X with 1 so that has to be

468
00:22:57,860 --> 00:22:59,870
该订单和该订单清楚地
the order and that order clearly

469
00:22:59,870 --> 00:23:01,850
违反了这是唯一一个
violates this is the only one order that

470
00:23:01,850 --> 00:23:03,620
秩序显然违反了第二条规则
order clearly violates the second rule

471
00:23:03,620 --> 00:23:06,620
关于价值观，那就是你知道的最多
about values that is you know the most

472
00:23:06,620 --> 00:23:08,930
最近右侧写入的值
value written by the most recent right

473
00:23:08,930 --> 00:23:10,910
在拥有的一个订单中，这是可能的
in the owned one order that's possible

474
00:23:10,910 --> 00:23:13,010
不是1，是2，所以这显然不是
is not 1 it's 2 so this is clearly not

475
00:23:13,010 --> 00:23:18,320
可线性化和我带来的原因
linearizable and the reason I'm bringing

476
00:23:18,320 --> 00:23:20,810
这是因为这是争论的焦点
it up is because this is the argument

477
00:23:20,810 --> 00:23:23,150
一个可线性化系统强
that a linearizable system a strongly

478
00:23:23,150 --> 00:23:25,580
一致的系统不能过时
consistent system cannot serve up stale

479
00:23:25,580 --> 00:23:29,780
数据是正确的，您知道原因是什么
data right and you know the reason why

480
00:23:29,780 --> 00:23:31,460
这可能会再次出现，你知道的
this might come up is again you know

481
00:23:31,460 --> 00:23:34,340
也许你们每个人都有很多复制品
maybe you have lots of replicas each you

482
00:23:34,340 --> 00:23:36,320
我知道可能还没有看到所有的权利
know maybe haven't seen all the rights

483
00:23:36,320 --> 00:23:37,520
或者所有承诺的权利或者别的什么
or all the committed rights or something

484
00:23:37,520 --> 00:23:40,460
所以可能会有一些，也许是所有的
so maybe there's some maybe all the

485
00:23:40,460 --> 00:23:42,230
复制品已经正确地看到了这一点，但只有
replicas have seen this right but only

486
00:23:42,230 --> 00:23:43,850
一些复制品已经正确地认识到了这一点
some replicas have seen this right and

487
00:23:43,850 --> 00:23:45,920
所以如果你问一个落后的复制品
so if you ask a replica that's lagging

488
00:23:45,920 --> 00:23:47,360
稍稍落后一点，它仍然会
behind a little bit it's still gonna

489
00:23:47,360 --> 00:23:50,590
X的值为1，但是
have value 1 for X but nevertheless

490
00:23:50,590 --> 00:23:53,600
客户端应该永远不会看到这一点
clients should never be able to see this

491
00:23:53,600 --> 00:23:57,980
可线性化系统中的旧值是
old value in a linearizable system are

492
00:23:57,980 --> 00:24:00,290
不允许陈旧的数据，不允许仍然
there no stale data allowed no still

493
00:24:00,290 --> 00:24:02,530
读取数
reads

494
00:24:21,510 --> 00:24:23,860
好的，如果时间间隔有重叠的话
yeah if there's overlap in the interval

495
00:24:23,860 --> 00:24:26,140
然后你知道你知道你
then there's then you know that you

496
00:24:26,140 --> 00:24:29,050
该系统是否可以合法地执行
could the system could legally execute

497
00:24:29,050 --> 00:24:31,150
他们中的任何一个都是实时的，而我在
either of them in a real-time and I in

498
00:24:31,150 --> 00:24:32,800
间隔，所以这就是意义所在
the interval so that's the sense in

499
00:24:32,800 --> 00:24:35,950
他们可以系统地执行
which they could system gonna execute

500
00:24:35,950 --> 00:24:38,070
现在你知道其他的顺序了
them in either order now you know other

501
00:24:38,070 --> 00:24:40,180
你知道如果不是这两个人
you know if it weren't for these two

502
00:24:40,180 --> 00:24:43,440
读取系统会让你知道
reads the system would have you know

503
00:24:43,440 --> 00:24:45,490
写入的完全自由执行
total freedom execute that writes in

504
00:24:45,490 --> 00:24:47,440
两个订单都不是因为我们看到了两个
either order but because we saw the two

505
00:24:47,440 --> 00:24:52,690
读到我们知道你知道唯一
reads we know that you know the only

506
00:24:52,690 --> 00:25:01,990
法律秩序是2，然后是1，是的，所以
legal order is two and then one yeah so

507
00:25:01,990 --> 00:25:03,310
如果两个预备队笑了，那么
if the two reserva laughing then and

508
00:25:03,310 --> 00:25:04,690
则读取可能具有的任何顺序
then any order then the reads could have

509
00:25:04,690 --> 00:25:07,150
其实你知道托比看到的
seen either in fact you know Toby saw

510
00:25:07,150 --> 00:25:08,320
这两个词和一个词都出自
the two and the one words all from the

511
00:25:08,320 --> 00:25:11,250
读了这些小玩意儿可能会让你知道
reads these doobies could have you know

512
00:25:11,250 --> 00:25:13,570
系统，直到它提交给
the system until it committed to the

513
00:25:13,570 --> 00:25:15,430
读它的价值观仍然是自由的
values for the read it still had freedom

514
00:25:15,430 --> 00:25:18,450
以任一顺序退还它们
to return them in either order

515
00:25:23,669 --> 00:25:28,780
我把它们当做同义词，对，对，你
I'm using them as synonyms yeah yeah you

516
00:25:28,780 --> 00:25:31,480
大多数人都知道，尽管有可能
know for most people although possibly

517
00:25:31,480 --> 00:25:34,660
不是今天的纸张线性化能力是
not today's paper linearize ability is

518
00:25:34,660 --> 00:25:37,900
定义得很好，而且是人们的
is well defined and and people's

519
00:25:37,900 --> 00:25:39,460
定义确实有很大的偏差
definitions really deviate very much

520
00:25:39,460 --> 00:25:43,750
从这种强烈的一致性来看，
from this strong consistency though is

521
00:25:43,750 --> 00:25:45,700
更少的我认为有更少的种类
less I think there's less sort of

522
00:25:45,700 --> 00:25:47,890
关于到底是什么达成了共识
consensus about exactly what the

523
00:25:47,890 --> 00:25:49,690
定义可能是如果你的意思是坚强
definition might be if you meant strong

524
00:25:49,690 --> 00:25:53,200
坚持不懈，通常是男人，通常是
consistency it's often men it's usually

525
00:25:53,200 --> 00:25:55,120
男人的方式也很接近
men too in ways that are quite close to

526
00:25:55,120 --> 00:25:55,780
这
this

527
00:25:55,780 --> 00:25:57,850
比如，哦，这个系统
like for example that oh the system

528
00:25:57,850 --> 00:26:00,640
的行为方式与具有以下特性的系统的行为方式相同
behaves the same way that a system with

529
00:26:00,640 --> 00:26:02,590
只有一份数据拷贝会有行为
only one copy of the data would behave

530
00:26:02,590 --> 00:26:05,169
好的，哪个比较接近什么？
all right which is quite close to what

531
00:26:05,169 --> 00:26:06,220
我们正在研究这个定义
we're getting at with this definition

532
00:26:06,220 --> 00:26:10,150
但是，是的，你知道，这是合理的
but yeah for you know it's reasonable to

533
00:26:10,150 --> 00:26:12,070
假设强强一致性是
assume that strong strong consistency is

534
00:26:12,070 --> 00:26:18,450
与可序列化相同，好的，这是
the same as serializable okay so this is

535
00:26:18,450 --> 00:26:21,400
不可线性化，而且你知道
not linearizable and the you know the

536
00:26:21,400 --> 00:26:26,350
我们得到的教训是杂草是不允许
the lesson is weeds are not allowed to

537
00:26:26,350 --> 00:26:29,830
仅返回陈旧数据仅返回最新数据
return stale data only only fresh data

538
00:26:29,830 --> 00:26:33,100
或者您只能返回
or you can only return the results of

539
00:26:33,100 --> 00:26:37,110
最近完成的右侧
the most recently completed right

540
00:26:44,700 --> 00:26:51,610
好的，我还有最后一个小例子
okay I have a final final little example

541
00:26:51,610 --> 00:26:54,660
所以我们有两个客户，其中一个
so we have two clients one of them

542
00:26:54,660 --> 00:26:58,060
向X提交值为3的写入
submits a write to X with value three

543
00:26:58,060 --> 00:27:04,450
然后编写两个值为4的动作和
and then write two acts with value 4 and

544
00:27:04,450 --> 00:27:07,930
我们还有另一个客户，你知道的
we have another client and you know at

545
00:27:07,930 --> 00:27:10,630
客户端在此时间点发出
this point in time the client issues a

546
00:27:10,630 --> 00:27:15,550
读到X，但这是一个你要问的问题
read of X but and this is a question you

547
00:27:15,550 --> 00:27:18,520
问客户没有得到
asked the the client doesn't get a

548
00:27:18,520 --> 00:27:21,910
答对了，你知道有谁知道
response right you know who knows like

549
00:27:21,910 --> 00:27:23,680
它在某种实际实施中
it in the sort of actual implementation

550
00:27:23,680 --> 00:27:25,420
可能是领队在某个时候坠毁了
may be the leader crashed at some point

551
00:27:25,420 --> 00:27:27,790
也许他的委托人会送来阅读器
maybe the his client to sent in the read

552
00:27:27,790 --> 00:27:29,890
所以领导可能没有得到
request so the leader maybe didn't get

553
00:27:29,890 --> 00:27:31,840
它是因为请求已被丢弃或
it because the request was dropped or

554
00:27:31,840 --> 00:27:34,540
也许领头人接到请求后
maybe the leader got the request and

555
00:27:34,540 --> 00:27:36,700
执行了它，但是网络上的响应
executed it but the response the network

556
00:27:36,700 --> 00:27:38,890
丢弃了回复，或者可能是领头人
dropped the response or maybe the leader

557
00:27:38,890 --> 00:27:40,870
我拿到了，开始往上走
got it and started to process up and

558
00:27:40,870 --> 00:27:42,700
然后在完成处理之前崩溃
then crash before finished processing

559
00:27:42,700 --> 00:27:44,680
或者可能确实处理过然后崩溃了
and or maybe did process it and crash

560
00:27:44,680 --> 00:27:45,940
在说出回应之前，谁知道呢？
before saying the response who knows

561
00:27:45,940 --> 00:27:48,160
当客户的观点像发送
when the clients point of view like sent

562
00:27:48,160 --> 00:27:50,140
一个请求，但从未得到过响应，所以在
a request and never got a response so in

563
00:27:50,140 --> 00:27:52,300
客户的内部机械用于
the interior machinery of the client for

564
00:27:52,300 --> 00:27:53,650
我们谈论的大多数系统
most of the systems we're talking about

565
00:27:53,650 --> 00:27:55,030
客户端将重新发送
the client is going to resend the

566
00:27:55,030 --> 00:27:57,700
请求可能会做不同的领导
request maybe do a different leader

567
00:27:57,700 --> 00:27:59,800
也许就是那个知道怎么回事的领导人
maybe the same leader who knows what so

568
00:27:59,800 --> 00:28:01,950
它把第一个问题送到了这里
it sent the first question quest here

569
00:28:01,950 --> 00:28:05,470
也许它会将第二个请求发送到
and maybe it sends the second request at

570
00:28:05,470 --> 00:28:07,150
你知道，这个时间点已经超时了
this point in time it times out you know

571
00:28:07,150 --> 00:28:10,450
没有响应在以下位置发送第二个请求
no response sends the second request at

572
00:28:10,450 --> 00:28:12,760
这一点，然后最终得到一个
this point and then finally gets a

573
00:28:12,760 --> 00:28:19,390
回答说，事实证明，你是这样做的
response it turns out that and you're

574
00:28:19,390 --> 00:28:22,320
我们将在实验3中实施此功能，
going to implement this in lab 3 that a

575
00:28:22,320 --> 00:28:26,830
服务器处理问题的合理方式
reasonable way of servers dealing with

576
00:28:26,830 --> 00:28:28,360
重复请求是针对其服务器的
repeated requests is for their servers

577
00:28:28,360 --> 00:28:31,540
要使表按某种方式编制索引，请执行以下操作
to keep tables sort of indexed by some

578
00:28:31,540 --> 00:28:32,920
唯一请求编号的类型或
kind of unique request number or

579
00:28:32,920 --> 00:28:35,080
一些来自客户的东西，在这些东西中
something from the clients in which the

580
00:28:35,080 --> 00:28:36,400
服务员记得吗，哦，我已经看过了
servers remember oh I already saw that

581
00:28:36,400 --> 00:28:38,890
请求并执行它，这是
request and executed it and this was the

582
00:28:38,890 --> 00:28:41,110
我发回的回复是因为你
response that I sent back because you

583
00:28:41,110 --> 00:28:42,690
我不想执行两次请求
don't want to execute a request twice

584
00:28:42,690 --> 00:28:45,400
你知道，如果它是一个例子，如果它是一个
you know if it's a for example if it's a

585
00:28:45,400 --> 00:28:47,410
您不想执行的写入请求
write request you don't want to execute

586
00:28:47,410 --> 00:28:49,300
请求正确，因此服务器必须
requests right so the server's have to

587
00:28:49,300 --> 00:28:51,000
能够用过滤发出重复的请求
be able to filter out duplicate requests

588
00:28:51,000 --> 00:28:53,950
而且他们必须能够退还
and they have to be able to return the

589
00:28:53,950 --> 00:28:56,020
答复以重复答复，即
reply to repeat the reply that the

590
00:28:56,020 --> 00:28:57,130
原来是这样的
originally

591
00:28:57,130 --> 00:28:59,049
发送给该请求者，该请求者可能已经
sent to that request which perhaps has

592
00:28:59,049 --> 00:29:00,730
被网络丢弃，因此服务器
dropped by the network so that servers

593
00:29:00,730 --> 00:29:04,559
记住最初的窥探并重复一遍
remember the original pry and repeat it

594
00:29:04,559 --> 00:29:07,870
作为对重新发送的响应，如果您这样做了
in response to the resend and if you do

595
00:29:07,870 --> 00:29:12,580
你们在实验3中要做的，如果你们
that which you will in lab 3 then if you

596
00:29:12,580 --> 00:29:16,299
我知道因为服务器能让领队
know since the server the leader could

597
00:29:16,299 --> 00:29:18,400
在它执行
have seen value 3 when it executed the

598
00:29:18,400 --> 00:29:20,799
客户端向其发出的原始读取请求
original read request from client to it

599
00:29:20,799 --> 00:29:23,860
可以将值3返回值3给重复的
could return value 3 to the repeated

600
00:29:23,860 --> 00:29:25,870
此时发送的请求，并且
requests that was sent at this time and

601
00:29:25,870 --> 00:29:30,460
在这个时候完工，所以我们必须
completed at this time and so we have to

602
00:29:30,460 --> 00:29:33,450
就这是否合法打个电话
make a call on whether that is legal

603
00:29:33,450 --> 00:29:38,020
是的，你可以争辩说，哦，天哪，你
right you could argue that oh gosh you

604
00:29:38,020 --> 00:29:39,640
知道我们在这里发送请求的客户吗
know the client we sent the request here

605
00:29:39,640 --> 00:29:41,169
这是在X24的右边
this was after the right of X 2 4

606
00:29:41,169 --> 00:29:42,429
完成了，所以上帝，你真正想要的是什么
completed so Jesus what you really

607
00:29:42,429 --> 00:29:44,679
应该在这一点上返回，而不是
should return for at this point instead

608
00:29:44,679 --> 00:29:52,020
3的大小，这有点像是
of 3 and this is like a little bit a

609
00:29:52,020 --> 00:29:55,150
关于它的问题好像有点上升了
question of it's like a little bit up

610
00:29:55,150 --> 00:29:58,510
设计者，但如果您查看的是
the designer but if what you view is

611
00:29:58,510 --> 00:30:00,460
是这样的，重播是
going on is that the retransmissions are

612
00:30:00,460 --> 00:30:05,080
一种低层次的担忧，这是你知道的一部分
a low-level concern that's you know part

613
00:30:05,080 --> 00:30:07,120
RPC机器或隐藏在某些
of the RPC machinery or hidden in some

614
00:30:07,120 --> 00:30:08,679
图书馆之类的，而且是从
library or something and that from the

615
00:30:08,679 --> 00:30:10,750
客户端应用程序视点全部
client applications point of view all

616
00:30:10,750 --> 00:30:12,730
发生的情况是它发送了一个
that happened was that it's sent a

617
00:30:12,730 --> 00:30:15,039
请求，并得到响应
request at this time and got a response

618
00:30:15,039 --> 00:30:17,289
就在这个时候，仅此而已
at this time and that's all that

619
00:30:17,289 --> 00:30:18,520
从客户的角度来看
happened from the clients point of view

620
00:30:18,520 --> 00:30:21,669
那么值3在这里是完全合法的
then a value of 3 is totally legal here

621
00:30:21,669 --> 00:30:24,150
因为这个请求花了很长时间
because this request took a long time

622
00:30:24,150 --> 00:30:26,350
它完全与
it's completely concurrent with the

623
00:30:26,350 --> 00:30:28,780
对不是实时订购的
right not ordered in real time with the

624
00:30:28,780 --> 00:30:31,900
对，因此要么是三个人，要么是
right and therefore either the three or

625
00:30:31,900 --> 00:30:34,330
这四个是有效的，你知道的，就好像
the four is valid you know as if the

626
00:30:34,330 --> 00:30:36,490
在此真正执行的读取请求
read requests that really executed here

627
00:30:36,490 --> 00:30:39,309
实时地或在这里实时地
in real time or or here in real time so

628
00:30:39,309 --> 00:30:42,730
更重要的教训是，如果您有客户
the larger lesson is if you have client

629
00:30:42,730 --> 00:30:47,320
从应用程序重新传输
retransmissions the from the application

630
00:30:47,320 --> 00:30:48,669
如果你定义的是
point of view if you're defining

631
00:30:48,669 --> 00:30:50,470
来自应用的线性化能力
linearize ability from the applications

632
00:30:50,470 --> 00:30:53,350
观点-即使在
point of view - even with

633
00:30:53,350 --> 00:30:56,200
重传数据的实时程度
retransmissions the real time extent of

634
00:30:56,200 --> 00:30:59,380
像这样的请求来自于
the requests like this is from the very

635
00:30:59,380 --> 00:31:01,240
将请求第一次传输到
first transmission of the requests to

636
00:31:01,240 --> 00:31:03,340
应用程序的最后时间
the final time at which the application

637
00:31:03,340 --> 00:31:05,710
实际上收到了回复，可能是在
actually got the response maybe after

638
00:31:05,710 --> 00:31:10,110
有很多理由是的
many reasons yes

639
00:31:24,790 --> 00:31:27,590
你可能宁愿你得到新的数据而不是
you might rather you got fresh data than

640
00:31:27,590 --> 00:31:30,560
陈旧的数据，你知道，如果我是你知道的
stale data you know if I'm you know

641
00:31:30,560 --> 00:31:32,360
假设请求是什么时间
supposing the request is what time it

642
00:31:32,360 --> 00:31:34,520
几点了，那是时间服务器I
what time is it that's a time server I

643
00:31:34,520 --> 00:31:35,990
发送了一个请求，说“哦，现在几点了？”
sent a request saying Oh what time is it

644
00:31:35,990 --> 00:31:38,570
它给了我一个回应，你知道的，是的。
and it sends me a response you know yeah

645
00:31:38,570 --> 00:31:40,400
如果我现在发出请求但我得不到
if I send a request now and I don't get

646
00:31:40,400 --> 00:31:42,980
从现在起到2分钟前的回复
the response until 2 minutes from now

647
00:31:42,980 --> 00:31:46,550
伙计，有些网络问题，可能是
dude some Network issue it may be that

648
00:31:46,550 --> 00:31:48,920
应用程序更愿意看到
the application would like prefer to see

649
00:31:48,920 --> 00:31:50,840
我们会得到它应该得到的回应
we're gonna get the response it would

650
00:31:50,840 --> 00:31:53,510
我更愿意看到一个接近的时间
prefer to see a time that was close to

651
00:31:53,510 --> 00:31:54,590
在这个时间里，实际上已经得到了
the time at which had actually got the

652
00:31:54,590 --> 00:31:56,750
响应，而不是深入到
response rather than a time deep in the

653
00:31:56,750 --> 00:31:58,190
在它最初发送请求的时间之后
past when it originally sent the request

654
00:31:58,190 --> 00:32:02,720
事实是，如果你知道如果你知道
now the fact is that if you you know if

655
00:32:02,720 --> 00:32:03,980
您使用的是您拥有的这样一个系统
you're using a system like this you have

656
00:32:03,980 --> 00:32:05,300
要编写容错的应用程序，请执行以下操作
to write applications that are tolerant

657
00:32:05,300 --> 00:32:09,470
对于您正在使用的这些规则，
of these rules you're using a

658
00:32:09,470 --> 00:32:11,240
像这样的线性化系统是
linearizable system like these are the

659
00:32:11,240 --> 00:32:13,730
规则，所以你必须写下你知道的
rules and so you must write you know

660
00:32:13,730 --> 00:32:15,880
正确的应用程序必须容忍
correct applications must be tolerant of

661
00:32:15,880 --> 00:32:17,900
你知道，如果他们发出请求，他们
you know if they send a request and they

662
00:32:17,900 --> 00:32:19,340
过一会儿就会得到回复，他们只是
get a response a while later they just

663
00:32:19,340 --> 00:32:22,340
你知道你不能不被允许
you know you can't are not allowed to

664
00:32:22,340 --> 00:32:25,190
编写应用程序就好像哦，天哪，如果我
write the application as if oh gosh if I

665
00:32:25,190 --> 00:32:27,290
获取一个响应，该响应表示该值
get a response that means that the value

666
00:32:27,290 --> 00:32:30,080
在我拿到的时候，他们的反应是一样的
at the time I got the response was equal

667
00:32:30,080 --> 00:32:32,240
设置为3，这对于应用程序来说是不正常的
to 3 that is not OK for applications to

668
00:32:32,240 --> 00:32:34,280
你以为你知道我有什么吗？
think you know what that I have that

669
00:32:34,280 --> 00:32:35,380
针对给定应用程序播放
plays out for a given application

670
00:32:35,380 --> 00:32:40,390
取决于应用程序正在执行的操作
depends on what the application is doing

671
00:32:40,600 --> 00:32:42,560
我之所以提起这件事是因为
the reason I bring this up is because

672
00:32:42,560 --> 00:32:45,530
这是一个常见的问题，在6、6、8到4岁的你
it's a common question in 6 6 8 to 4 you

673
00:32:45,530 --> 00:32:47,780
伙计们将通过以下方式实施机器
guys will implement the machinery by

674
00:32:47,780 --> 00:32:51,080
哪些服务器检测到重复项并
which servers detect duplicates and

675
00:32:51,080 --> 00:32:56,180
重新发送上一个答案，即
resend the previous answer that the

676
00:32:56,180 --> 00:32:57,500
最初发送的服务器和问题
server originally sent and the question

677
00:32:57,500 --> 00:33:00,800
会上来的，如果你原来是这样的可以吗？
will come up is it ok if you originally

678
00:33:00,800 --> 00:33:02,810
我在这里看到了在此返回的请求
saw the request here to return at this

679
00:33:02,810 --> 00:33:05,450
您响应的时间点
point in time the response that you

680
00:33:05,450 --> 00:33:08,060
会送回这里，如果网络
would have sent back here if the network

681
00:33:08,060 --> 00:33:11,720
没有掉在地上，这是很方便的
hadn't dropped it and it's it's handy to

682
00:33:11,720 --> 00:33:13,910
有一种推理的方式，我是说
have a kind of way of reasoning I mean

683
00:33:13,910 --> 00:33:15,020
有这样的定义的一个原因是
one reason to have definitions like

684
00:33:15,020 --> 00:33:16,400
将能力线性化，以便能够进行推理
linearize abilities to be able to reason

685
00:33:16,400 --> 00:33:18,290
关于这样的问题，我是对的
about questions like that right i'm

686
00:33:18,290 --> 00:33:21,920
使用这个方案，我们可以说很好
using using this scheme we can say well

687
00:33:21,920 --> 00:33:25,480
按照那些规则实际上是可以的。
it actually is okay by those rules

688
00:33:26,210 --> 00:33:28,080
好了，我想说的就是这些。
all right that's all i want to say about

689
00:33:28,080 --> 00:33:32,010
线性化任何逗留的能力
linearize ability of any any lingering

690
00:33:32,010 --> 00:33:35,810
问题是的
questions yeah

691
00:33:45,230 --> 00:33:49,039
嗯，你知道，也许我太放肆了
well you know maybe I'm taking liberties

692
00:33:49,039 --> 00:33:55,460
在这里，但真正发生的是
here but what's going on is that in real

693
00:33:55,460 --> 00:33:57,620
我们读过的时间-和读过的
time we have a read of - and a read of

694
00:33:57,620 --> 00:33:59,899
一声和一声的朗读真的来了
one and the read of one really came

695
00:33:59,899 --> 00:34:01,730
在实时读取两个和之后
after in real time the read of two and

696
00:34:01,730 --> 00:34:04,519
所以一定是按照这个顺序来的
so must come must be in this order in

697
00:34:04,519 --> 00:34:07,580
最后的订单，也就是说必须
the final order that means there must

698
00:34:07,580 --> 00:34:11,449
一直是一种权利-在这里的某个地方
have been a right of - somewhere in here

699
00:34:11,449 --> 00:34:13,129
这是我们的权利，在某个地方有价值一
it's our right with value one somewhere

700
00:34:13,129 --> 00:34:15,770
在这里，那是在读完-in之后
in here that is after the read of - in

701
00:34:15,770 --> 00:34:17,780
在宣读完后的最后一份订单
the final order right after the read of

702
00:34:17,780 --> 00:34:20,449
-在阅读其中一个之前
- and before the read of one in that

703
00:34:20,449 --> 00:34:22,040
订单中必须有有价值的权利
order there must be a right with value

704
00:34:22,040 --> 00:34:23,869
一只有价值的权利只有一个
one there's only one right with a value

705
00:34:23,869 --> 00:34:25,339
没有空房，你知道如果还有更多的话
unavailable you know if there were more

706
00:34:25,339 --> 00:34:27,079
我们也许可以玩游戏，但是
than one we maybe could play games but

707
00:34:27,079 --> 00:34:29,300
只有一个空位，所以这是对的。
there's only one available so this right

708
00:34:29,300 --> 00:34:31,790
必须以最后的顺序溜进这里，否则
must slip in here in the final order or

709
00:34:31,790 --> 00:34:38,770
所以我觉得我可以画出这个箭头
therefore I felt able to draw this arrow

710
00:34:38,770 --> 00:34:42,139
这些箭头正好捕捉到了
and these arrows just capture the sort

711
00:34:42,139 --> 00:34:44,179
规则的一个接一个的含义
of one by one implication of the rules

712
00:34:44,179 --> 00:34:50,290
看订单一定是什么样子的，是的。
on what the order must look like yeah

713
00:35:02,490 --> 00:35:06,820
好的，是的，我的意思是任何时候或者X，那么
all right yeah I mean any hour or X so

714
00:35:06,820 --> 00:35:16,560
哪位抱歉哪位是他自己的RX1
which sorry which which yeah his own rx1

715
00:35:16,560 --> 00:35:19,960
他在他自己的RX1之前就看到了，好的，那么
he sees it before his own rx1 okay so

716
00:35:19,960 --> 00:35:32,790
途经，是的，我们不是，我们不是
the via yep well we're not we're not

717
00:35:32,790 --> 00:35:35,890
我们真的不能说是哪一个
we're not really able to say which of

718
00:35:35,890 --> 00:35:39,580
这两颗小麦先到，所以我们不能
these two wheats came first so we can't

719
00:35:39,580 --> 00:35:41,470
如果我们是认真的，这一切都是错误的
quite for all this error if we mean this

720
00:35:41,470 --> 00:35:43,810
用于约束最终顺序的箭头
arrow to constrain the ultimate order

721
00:35:43,810 --> 00:35:46,300
我们不是你知道的这两种杂草
we're not you know the these two weeds

722
00:35:46,300 --> 00:35:48,220
可能有两种顺序，所以我们不会
could come in either order so we're not

723
00:35:48,220 --> 00:35:49,690
允许我说这件事发生在那之前
allowed to say this one came before that

724
00:35:49,690 --> 00:35:52,420
一种可能是有一个更简单的循环
one it could be there's a simpler cycle

725
00:35:52,420 --> 00:35:55,300
实际上，然后我画了画，所以我是认真的
actually then I've drawn so I mean it

726
00:35:55,300 --> 00:35:58,360
可能是因为可以肯定的是
may be because certainly the that the

727
00:35:58,360 --> 00:36:02,560
损坏在这四项中，我同意。
damage is in these four items I agree

728
00:36:02,560 --> 00:36:05,380
有了这两个，这四个项目
with that these two these four items

729
00:36:05,380 --> 00:36:08,860
在某种程度上是主要的证据
kind of are the main evidence that

730
00:36:08,860 --> 00:36:09,700
有些事不对劲
something is wrong

731
00:36:09,700 --> 00:36:11,860
现在是一个循环我不确定是不是
now whether a cycle I'm not sure whether

732
00:36:11,860 --> 00:36:13,240
有一个循环就是涉及到这一点
there's a cycle that just involves that

733
00:36:13,240 --> 00:36:16,930
可能会好的，这是值得的
there could be okay this is worth

734
00:36:16,930 --> 00:36:19,540
想着因为你知道如果我不能
thinking about cuz you know if I can't

735
00:36:19,540 --> 00:36:20,440
想点更好的，否则我就
think of anything better or I'll

736
00:36:20,440 --> 00:36:21,460
我当然会问你一个关于
certainly ask you a question about

737
00:36:21,460 --> 00:36:27,240
期中考试的可线性化历史
linearizable histories on midterm

738
00:36:31,010 --> 00:36:36,740
好的，那么今天的报纸今天的报纸
okay so today's paper today's paper

739
00:36:36,740 --> 00:36:43,670
动物园管理员和我的意思是部分原因
zookeeper and I mean part of the reason

740
00:36:43,670 --> 00:36:45,109
我们甚至是动物园管理员的纸就是它
we're even zookeeper paper is that it's

741
00:36:45,109 --> 00:36:46,790
一个成功的现实世界系统，它是一个
a successful real world system it's an

742
00:36:46,790 --> 00:36:50,660
开放源码您知道的服务
open source you know service that

743
00:36:50,660 --> 00:36:51,920
实际上，罗恩去过的人很多
actually a lot of people ron has been

744
00:36:51,920 --> 00:36:53,510
融入了很多现实世界
incorporated into a lot of real world

745
00:36:53,510 --> 00:36:55,460
软件，所以有一种特定的
software so there's a certain kind of

746
00:36:55,460 --> 00:36:59,780
现实和成功，但是你知道
reality and success to it but you know

747
00:36:59,780 --> 00:37:00,890
从这一点来看，这让人觉得很有吸引力
that makes attractive from the point of

748
00:37:00,890 --> 00:37:04,310
在某种程度上支持这样一种观点的观点
view of kind of supporting the idea that

749
00:37:04,310 --> 00:37:05,660
动物园管理员的设计可能实际上是
the zookeepers design might actually be

750
00:37:05,660 --> 00:37:08,210
一个合理的设计，但我们之所以
a reasonable design but the reason we're

751
00:37:08,210 --> 00:37:10,220
对它感兴趣我对它感兴趣
interested in in it I'm interested in it

752
00:37:10,220 --> 00:37:12,410
更准确地说，是为了
is for to somewhat more precise

753
00:37:12,410 --> 00:37:18,320
技术上的观点那么我们为什么要
technical points so why are we looking

754
00:37:18,320 --> 00:37:23,090
在这篇论文中，其中之一就是在
at this paper so one of them is that in

755
00:37:23,090 --> 00:37:25,520
与你的救生筏形成鲜明对比的是
contrast to raft like the raft you've

756
00:37:25,520 --> 00:37:27,350
就像定义的那样，它是书面的和木筏的
written and raft as that's defined it's

757
00:37:27,350 --> 00:37:29,180
真的是一个您知道的库，您可以使用
really a library you know you can use a

758
00:37:29,180 --> 00:37:31,670
筏子库作为一些更大的
raft library as a part of some larger

759
00:37:31,670 --> 00:37:34,400
复制系统，但RAFT不像
replicated system but raft isn't like a

760
00:37:34,400 --> 00:37:36,440
独立服务或您
standalone service or something that you

761
00:37:36,440 --> 00:37:38,330
你可以和它说话，这是你真的必须要说的
can talk to it's you really have to

762
00:37:38,330 --> 00:37:40,430
将您的应用程序设计为在
design your application to interact at

763
00:37:40,430 --> 00:37:45,170
明确地描述了筏子库，这样您就可以
the raft library explicitly so you might

764
00:37:45,170 --> 00:37:46,820
不知道这是个有趣的问题
wonder it's an interesting question

765
00:37:46,820 --> 00:37:52,060
是否有一些有用的系统
whether some useful system sort of

766
00:37:52,060 --> 00:37:54,530
独立的通用系统可以
standalone general-purpose system could

767
00:37:54,530 --> 00:37:56,600
被定义为对以下方面有帮助的
be defined that would be helpful for

768
00:37:56,600 --> 00:37:59,240
人们构建独立的分布式建筑
people building separate distributed

769
00:37:59,240 --> 00:38:00,920
像“有没有”这样的系统提供一些服务？
systems like is there serve some service

770
00:38:00,920 --> 00:38:02,780
可以咬掉很大一部分
that can bite off a significant portion

771
00:38:02,780 --> 00:38:04,520
为什么构建分布式是痛苦的
of why it's painful to build distributed

772
00:38:04,520 --> 00:38:06,440
系统，并将其打包在一个
systems and sort of package it up in a

773
00:38:06,440 --> 00:38:09,140
您认识的任何人都可以提供独立服务
standalone service that you know anybody

774
00:38:09,140 --> 00:38:14,090
所以这才是真正的问题所在
can use so this is really the question

775
00:38:14,090 --> 00:38:16,730
的API会是什么样子的
of what would an API look like for a

776
00:38:16,730 --> 00:38:24,230
一般用途，我就叫它，我不是
general purpose I'll call it I'm not

777
00:38:24,230 --> 00:38:25,670
当然可以，像这样的东西的正确名称是什么？
sure what the right name for things like

778
00:38:25,670 --> 00:38:27,740
动物园管理员是，但你有一个将军
zookeeper is but you've got a general

779
00:38:27,740 --> 00:38:32,200
目的协调服务
purpose coordination service

780
00:38:33,930 --> 00:38:37,480
另一个问题，另一个问题
and the other question the other

781
00:38:37,480 --> 00:38:41,760
动物园管理员有趣的一面是
interesting aspect of zookeeper is that

782
00:38:41,760 --> 00:38:44,079
当我们构建复制系统并
when we build replicated systems and

783
00:38:44,079 --> 00:38:45,460
动物园饲养员复制系统是因为
zookeepers a replicated system because

784
00:38:45,460 --> 00:38:47,260
在其他事情中，它就像一个
among other things it's it's like a

785
00:38:47,260 --> 00:38:48,630
容错
fault-tolerant

786
00:38:48,630 --> 00:38:51,609
通用协调服务和
general-purpose coordination service and

787
00:38:51,609 --> 00:38:53,500
它和大多数产品一样具有容错能力
it gets fault tolerance like most

788
00:38:53,500 --> 00:38:55,599
按复制划分的系统，即存在
systems by replication that is there's a

789
00:38:55,599 --> 00:38:57,579
你们中的一些人可能知道三五个人
bunch of you know maybe three or five or

790
00:38:57,579 --> 00:38:58,780
七个或者谁知道是什么
seven or who knows what

791
00:38:58,780 --> 00:39:03,039
动物园管理员服务器需要花钱才能买到
zookeeper servers it takes money to buy

792
00:39:03,039 --> 00:39:05,049
这些服务器就像一台7号服务器
those servers right like a 7 server

793
00:39:05,049 --> 00:39:09,160
设置动物园管理员的费用是
zookeeper setup is 7 times expensive as

794
00:39:09,160 --> 00:39:13,510
一种简单的单一服务器，所以它
a sort of simple single server so it's

795
00:39:13,510 --> 00:39:16,240
我很想问你是不是买了7
very tempting to ask if you buy 7

796
00:39:16,240 --> 00:39:17,920
运行复制服务的服务器
servers to run your replicated service

797
00:39:17,920 --> 00:39:20,319
你能把表演提高7倍吗？
can you get 7 times the performance out

798
00:39:20,319 --> 00:39:24,010
7台服务器中的任何一台都是正确的，并且您知道如何
of your 7 servers right and you know how

799
00:39:24,010 --> 00:39:29,109
我们能不能这样做，这样
could we possibly do that so the

800
00:39:29,109 --> 00:39:31,900
问题是你知道我们有n倍于
question is you know we have n times as

801
00:39:31,900 --> 00:39:35,530
许多服务器可以为我们带来n倍的收益
many servers can that yield us n times

802
00:39:35,530 --> 00:39:42,190
所以我要说的是
the performance so I'm gonna talk about

803
00:39:42,190 --> 00:39:46,450
第二个问题首先是从
the second question first so from the

804
00:39:46,450 --> 00:39:47,529
关于这个讨论的观点
point of view this discussion about

805
00:39:47,529 --> 00:39:50,799
我正要去看演出
performance I'm just going to view

806
00:39:50,799 --> 00:39:53,140
动物园饲养员只是一项我们不提供的服务
zookeeper as just some service we don't

807
00:39:53,140 --> 00:39:54,609
我真的很在乎这项服务是什么，但是
really care what the service is but

808
00:39:54,609 --> 00:39:57,579
使用类似筏子的复制进行复制
replicated with a raft like replication

809
00:39:57,579 --> 00:39:59,470
系统动物园管理员实际上运行在
system zookeeper actually runs on top of

810
00:39:59,470 --> 00:40:03,069
这个叫Zab的东西是为我们的
this thing called Zab which for our

811
00:40:03,069 --> 00:40:05,220
目的
purposes

812
00:40:06,320 --> 00:40:09,480
我们就当几乎是
we'll just treat as being almost

813
00:40:09,480 --> 00:40:14,849
和木筏一模一样，我只是
identical to the raft and I'm just

814
00:40:14,849 --> 00:40:15,990
我担心的是
worried about the performance of the

815
00:40:15,990 --> 00:40:17,640
我并不真的担心复制
replication I'm not really worried about

816
00:40:17,640 --> 00:40:20,160
动物园管理员具体在做什么呢？
what zookeepers specifically is up to so

817
00:40:20,160 --> 00:40:22,140
大体情况是你知道我们
the general picture is that you know we

818
00:40:22,140 --> 00:40:24,240
有一堆客户，可能有几百个
have a bunch of clients maybe hundreds

819
00:40:24,240 --> 00:40:27,840
可能有数百个客户，我们有
maybe hundreds of clients and we have

820
00:40:27,840 --> 00:40:35,400
就像小伙子们一样，我们有一个领袖
just as in the lads we have a leader the

821
00:40:35,400 --> 00:40:37,740
Leader有一个动物园管理员层，
leader has a zookeeper layer that

822
00:40:37,740 --> 00:40:39,810
客户与之交谈，然后在
clients talk to and then under the

823
00:40:39,810 --> 00:40:42,510
ZooKeeper层是XAB系统，它
zookeeper layer is the xab system that

824
00:40:42,510 --> 00:40:44,730
然后，就像木筏一样管理复制
manages replication then just like rafts

825
00:40:44,730 --> 00:40:47,190
这是一大堆正在做的事情
what was a a lot of what's that is doing

826
00:40:47,190 --> 00:40:49,859
正在维护包含
is maintaining a log that contains the

827
00:40:49,859 --> 00:40:51,510
客户端拥有的操作顺序
sequence of operations that clients have

828
00:40:51,510 --> 00:40:57,930
送来的真的很像木筏
sent in really very similar to raft may

829
00:40:57,930 --> 00:41:01,500
有一堆这样的东西，每个都有
have a bunch of these and each of them

830
00:41:01,500 --> 00:41:09,380
有日志，但这是一个挂起的新请求
has a log but it's a pending new request

831
00:41:10,369 --> 00:41:15,410
这是一个熟悉的设置，所以
that's a familiar set up so the

832
00:41:15,410 --> 00:41:18,119
克林顿在请求和扎布层
Clinton's in a request and the Zab layer

833
00:41:18,119 --> 00:41:21,830
您知道，将该请求的副本发送到
you know sends a copy of that request to

834
00:41:21,830 --> 00:41:24,210
每个复制品和复制品
each of the replicas and the replicas

835
00:41:24,210 --> 00:41:25,440
把这个附加到他们的内存法则中，我会
append this to their in-memory law I'd

836
00:41:25,440 --> 00:41:28,440
可能保存在磁盘上，所以他们
probably persisted onto a disk so they

837
00:41:28,440 --> 00:41:29,520
如果他们坠毁了，可以把它拿回来
can get it back if they crash and

838
00:41:29,520 --> 00:41:35,190
重新启动，因此问题是在我们添加
restart so the question is as we add

839
00:41:35,190 --> 00:41:36,660
更多的服务器，你知道，我们可以有四台
more servers you know we could have four

840
00:41:36,660 --> 00:41:38,490
服务器或五七台或其他任何服务器
servers or five or seven or whatever

841
00:41:38,490 --> 00:41:41,099
系统会随着我们的添加而变得更快吗
does the system get faster as we add

842
00:41:41,099 --> 00:41:48,960
更多的CPU，更多的马力去做
more more CPUs more horsepower to it do

843
00:41:48,960 --> 00:41:50,430
你觉得你的实验室会变得更快
you think your labs will get faster as

844
00:41:50,430 --> 00:41:53,820
假设你有更多的复制品
you have more replicas assuming they're

845
00:41:53,820 --> 00:41:56,070
每个副本都有自己的计算机，因此
each replicas its own computer right so

846
00:41:56,070 --> 00:41:58,020
您确实可以获得更多的CPU周期
that you really do get more CPU cycles

847
00:41:58,020 --> 00:42:00,980
随着您增加更多的收入
as you add more revenues

848
00:42:09,440 --> 00:42:12,829
在所有的
between all the

849
00:42:17,280 --> 00:42:19,330
是啊，是啊，这没什么大不了的
yeah yeah there's nothing about this

850
00:42:19,330 --> 00:42:20,530
当您添加更多的内容时，这会使它变得更快
that makes it faster as you add more

851
00:42:20,530 --> 00:42:23,110
服务生说的对，绝对是真的，就像
servers right it's absolutely true like

852
00:42:23,110 --> 00:42:25,780
随着我们拥有更多的服务器，您知道
as we have more servers you know the

853
00:42:25,780 --> 00:42:27,100
几乎可以肯定，领导者是一个瓶颈。
leader is almost certainly a bottleneck

854
00:42:27,100 --> 00:42:28,330
因为领导必须处理每一个
cuz the leader has to process every

855
00:42:28,330 --> 00:42:30,130
请求时，它会发送每个
request and it sends a copy of every

856
00:42:30,130 --> 00:42:31,630
在您添加时向所有其他服务器发出请求
request to every other server as you add

857
00:42:31,630 --> 00:42:33,760
更多的服务器，这只会增加更多的工作
more servers it just adds more work to

858
00:42:33,760 --> 00:42:36,220
这个瓶颈节点，对，你不是
this bottleneck node right you're not

859
00:42:36,220 --> 00:42:37,720
获得任何好处任何性能
getting any benefit any performance

860
00:42:37,720 --> 00:42:39,070
从添加的服务器中获益，因为
benefit out of the added servers because

861
00:42:39,070 --> 00:42:40,120
他们真的什么都没做
they're not really doing anything

862
00:42:40,120 --> 00:42:42,910
他们只是都很开心地做任何事
they're just all happily doing whatever

863
00:42:42,910 --> 00:42:45,930
领导告诉他们去做他们没有做的事
the leader tells them to do they're not

864
00:42:45,930 --> 00:42:48,160
你知道从领先者身上减去
you know subtracting from the leaders

865
00:42:48,160 --> 00:42:50,200
每一项工作和每一项操作都要
work and every single operation goes to

866
00:42:50,200 --> 00:42:54,220
领导，所以在这里，你知道
the leader so for here you know the

867
00:42:54,220 --> 00:42:56,020
你所知的表现是相反的
performance is you know inversely

868
00:42:56,020 --> 00:42:58,300
与服务器数量成比例
proportional to the number of servers

869
00:42:58,300 --> 00:42:59,590
如果您添加了更多服务器，则会在此添加更多服务器
that you add you add more servers this

870
00:42:59,590 --> 00:43:02,350
几乎可以肯定会变得更低，因为
almost certainly gets lower because the

871
00:43:02,350 --> 00:43:04,780
领导只是有更多的工作要做，所以在这件事上
leader just has more work so in this

872
00:43:04,780 --> 00:43:06,790
系统我们有更多的问题
system we have the problem that more

873
00:43:06,790 --> 00:43:15,370
服务器会使系统变慢，这就是
servers makes the system slower that's

874
00:43:15,370 --> 00:43:16,720
太糟糕了，你知道这些服务器的价格是
too bad you know these servers cost a

875
00:43:16,720 --> 00:43:18,370
每人几千美元，你就会
couple thousand bucks each and you would

876
00:43:18,370 --> 00:43:20,320
希望你能用它们来
hope that you could use them to get

877
00:43:20,320 --> 00:43:25,650
更好的性能是的
better performance yeah

878
00:43:33,040 --> 00:43:35,710
好的，所以问题是如果
okay so the question is what if the

879
00:43:35,710 --> 00:43:38,080
请求可能来自不同的客户端
requests may be from different clients

880
00:43:38,080 --> 00:43:39,610
或连续的请求和相同的客户端
or successive requests and same client

881
00:43:39,610 --> 00:43:41,500
或者别的什么，如果这些要求适用怎么办？
or something what if the requests apply

882
00:43:41,500 --> 00:43:43,450
这个州的两个完全不同的地方
two totally different parts of the state

883
00:43:43,450 --> 00:43:45,340
所以你知道在密钥值商店里也许
so you know in a key value store maybe

884
00:43:45,340 --> 00:43:46,960
其中一个是穿在X身上的，另一个是穿在X身上的
one of them is a put on X and the other

885
00:43:46,960 --> 00:43:48,730
是一个装腔作势的人，好像和这件事没什么关系
was a put on Y like nothing to do with

886
00:43:48,730 --> 00:43:52,270
你认识的彼此我们能带上
each other you know can we take

887
00:43:52,270 --> 00:43:55,000
这一点的优势和答案是
advantage of that and the answer that is

888
00:43:55,000 --> 00:43:57,790
现在绝对不在这个框架内
absolutely now not in this framework

889
00:43:57,790 --> 00:44:00,790
不过，或者它是我们能做到的中心
though or it's the center which we can

890
00:44:00,790 --> 00:44:02,470
好好利用它吧，它是非常有限的。
take advantage of it it's very limited

891
00:44:02,470 --> 00:44:06,370
在这个框架中，它可以很好地
in this framework it could be well at a

892
00:44:06,370 --> 00:44:08,710
高层领导对一切的要求
high level the leader the requests all

893
00:44:08,710 --> 00:44:11,920
还是要经过领队和
still go through the leader and the

894
00:44:11,920 --> 00:44:13,390
领导还是要把它发给所有人
leader still has to send it out to all

895
00:44:13,390 --> 00:44:15,160
复制品和那里的复制品越多
the replicas and the more replicas there

896
00:44:15,160 --> 00:44:17,200
领导者要传达的信息就越多
are the more messages the leader has to

897
00:44:17,200 --> 00:44:19,990
所以在高层发送，不太可能
send so at a high level it's not likely

898
00:44:19,990 --> 00:44:23,890
去这种交换性的或社区的
to this sort of commutative or community

899
00:44:23,890 --> 00:44:25,420
请求的数量不太可能对此有所帮助
of requests is not likely to help this

900
00:44:25,420 --> 00:44:28,120
情况是一个值得保留的奇妙想法
situation is a fantastic thought to keep

901
00:44:28,120 --> 00:44:29,500
别忘了，因为这绝对会
in mind though because it'll absolutely

902
00:44:29,500 --> 00:44:32,890
在其他系统中出现，人们会
come up in other systems and people will

903
00:44:32,890 --> 00:44:34,270
能够在其他地方利用它
be able to take advantage of it in other

904
00:44:34,270 --> 00:44:39,730
系统正常，所以有一点
systems okay so so there's a little bit

905
00:44:39,730 --> 00:44:41,560
服务器硬件方面令人失望的事实
disappointing facts with server hardware

906
00:44:41,560 --> 00:44:48,540
对表演没有帮助，所以非常
wasn't helping performance so a very

907
00:44:48,540 --> 00:44:52,300
很明显，也许是最简单的方式
sort of obvious maybe the simplest way

908
00:44:52,300 --> 00:44:54,550
你也许可以利用这些
that you might be able to harness these

909
00:44:54,550 --> 00:44:57,430
其他服务器正在构建一个系统，在该系统中
other servers is build a system in which

910
00:44:57,430 --> 00:44:59,860
您的写入请求都必须通过
ya write requests all have to go through

911
00:44:59,860 --> 00:45:03,220
领导者，但在现实世界中却是一个巨大的
the leader but in the real world a huge

912
00:45:03,220 --> 00:45:05,380
读取繁重的工作负载的数量
number of workloads are read heavy that

913
00:45:05,380 --> 00:45:06,700
是不是有更多的读物，比如当你
is there's many more reads like when you

914
00:45:06,700 --> 00:45:07,960
看看网页，你知道这就是一切
look at web pages you know it's all

915
00:45:07,960 --> 00:45:09,970
关于读取数据以生成Web
about reading data to produce the web

916
00:45:09,970 --> 00:45:11,740
页面和一般都有非常多
page and generally there are very

917
00:45:11,740 --> 00:45:13,660
相对较少的权利，这是真实的
relatively few rights and that's true of

918
00:45:13,660 --> 00:45:15,070
有很多系统，所以也许我们会把
a lot of systems so maybe we'll send

919
00:45:15,070 --> 00:45:18,310
对领导者的权利，但只是送去杂草
rights to the leader but send weeds just

920
00:45:18,310 --> 00:45:21,640
其中一个复制品，只需挑选
to one of the replicas right just pick

921
00:45:21,640 --> 00:45:22,840
其中一个复制品，如果您有一个
one of the replicas and if you have a

922
00:45:22,840 --> 00:45:24,940
只读请求，如实验3中的GET
read-only request like a get in lab 3

923
00:45:24,940 --> 00:45:26,200
只要把它寄给其中一个复制品
just send it to one of the replicas and

924
00:45:26,200 --> 00:45:29,350
如果我们现在这样做，我们就不会对领导说
not to the leader now if we do that we

925
00:45:29,350 --> 00:45:30,520
虽然对人权没有太大帮助
haven't helped rights much although

926
00:45:30,520 --> 00:45:32,020
我们减少了大量的阅读工作
we've gotten a lot of read workload off

927
00:45:32,020 --> 00:45:33,700
领导，所以这可能会有帮助，但是我们
the leader so maybe that helps but we

928
00:45:33,700 --> 00:45:36,400
绝对取得了巨大的进步
absolutely have made tremendous progress

929
00:45:36,400 --> 00:45:38,560
读取，因为现在服务器越多
with reads because now the more servers

930
00:45:38,560 --> 00:45:42,550
我们添加的客户端越多，我们可以支持的客户端就越多
we add the more clients we can support

931
00:45:42,550 --> 00:45:44,080
对，因为我们只是平分
right because we're just splitting the

932
00:45:44,080 --> 00:45:45,390
客户领导工作
client lead work

933
00:45:45,390 --> 00:45:48,180
跨不同的复制副本，因此
across the different replicas so the

934
00:45:48,180 --> 00:45:51,930
问题是如果我们让客户
question is if we have clients send

935
00:45:51,930 --> 00:45:55,710
直接送到复制品，我们是不是要
directly to the replicas are we going to

936
00:45:55,710 --> 00:45:58,100
快快乐乐的
be happy

937
00:46:07,270 --> 00:46:10,450
是的，所以最新的是正确的是
yeah so up-to-date does the right is the

938
00:46:10,450 --> 00:46:13,119
在类似木筏的系统中使用正确的词
right word in a raft like system which

939
00:46:13,119 --> 00:46:17,970
ZooKeeper是如果客户端发送请求
zookeeper is if a client sends a request

940
00:46:17,970 --> 00:46:20,800
到一个随机的复制品，你知道的
to a random replica you know sure the

941
00:46:20,800 --> 00:46:22,869
您知道的复本中有一份日志副本
replica you know has a copy the log in

942
00:46:22,869 --> 00:46:24,940
如果你知道它一直在执行
it you know it's been executing along

943
00:46:24,940 --> 00:46:26,950
和领队在一起，你知道的，在实验3
with the leader and you know for lab 3

944
00:46:26,950 --> 00:46:29,530
它有这个键值表格，而你
it's got this key value table and you

945
00:46:29,530 --> 00:46:31,990
我知道你做了一个键X的GET，它是
know you do a get for key X and it's

946
00:46:31,990 --> 00:46:34,510
会有四张关键的出走桌子
gonna have some four key exodus table

947
00:46:34,510 --> 00:46:36,099
它可以回复你这样一种
and it can reply to you so sort of

948
00:46:36,099 --> 00:46:38,980
从功能上讲，复制品得到了所有
functionally the replicas got all the

949
00:46:38,980 --> 00:46:40,869
它需要响应客户端的条目
pieces it needs to respond to client to

950
00:46:40,869 --> 00:46:44,260
来自客户端的读取请求
read requests from clients the

951
00:46:44,260 --> 00:46:47,109
困难在于没有理由
difficulty is that there's no reason to

952
00:46:47,109 --> 00:46:49,300
相信任何人的复制品除了
believe that anyone replicas other than

953
00:46:49,300 --> 00:46:54,130
领导是最新的，因为很好
the leader is up to date because well

954
00:46:54,130 --> 00:46:56,080
有一大堆原因可以解释为什么
there's a bunch of reasons why why

955
00:46:56,080 --> 00:46:57,880
以下副本之一可能不是最新的
replicas may not be up to date one of

956
00:46:57,880 --> 00:46:59,650
就是他们可能不在
them is that they may not be in the

957
00:46:59,650 --> 00:47:02,230
领袖等待的多数
majority that the leader was waiting for

958
00:47:02,230 --> 00:47:04,089
你想一想木筏在做什么
you think about what raft is doing the

959
00:47:04,089 --> 00:47:05,740
领导只有义务等待
leader is only obliged to wait for

960
00:47:05,740 --> 00:47:07,599
对其附加条目的响应来自
responses to its append entries from a

961
00:47:07,599 --> 00:47:10,599
大多数追随者，然后它
majority of the followers and then it

962
00:47:10,599 --> 00:47:11,950
可以提交操作并继续
can commit the operation and go on to

963
00:47:11,950 --> 00:47:14,260
下一个操作，所以如果这个复制品
the next operation so if this replica

964
00:47:14,260 --> 00:47:16,330
它可能永远不会占多数
wasn't in the majority it may never have

965
00:47:16,330 --> 00:47:18,790
看到一场骚乱，可能是网络
seen a riot it may be the network

966
00:47:18,790 --> 00:47:20,950
它掉了，再也没有拿到，所以是的
dropped it and never got it and so yeah

967
00:47:20,950 --> 00:47:25,530
你认识领导，你认识一个
you know the leader and you know a

968
00:47:25,530 --> 00:47:27,820
大多数服务器都已看到
majority of the servers have seen the

969
00:47:27,820 --> 00:47:30,000
前三个请求，但你知道这一点
first three requests but you know this

970
00:47:30,000 --> 00:47:31,990
服务器只看到了它的前两个
server only saw the first two it's

971
00:47:31,990 --> 00:47:35,260
错过了B，所以读起来就是对你的读
missing B so read to be a read of you

972
00:47:35,260 --> 00:47:37,300
知道那里应该有什么，我就在那里
know what should be there I'll just be

973
00:47:37,300 --> 00:47:40,740
从这辆车里得到的完全是陈旧的价值
totally get a stale value from this one

974
00:47:40,740 --> 00:47:45,490
即使这个复制品真的看到了这个
even if this replica actually saw this

975
00:47:45,490 --> 00:47:47,320
新日志条目它可能缺少
new log entry it might be missing the

976
00:47:47,320 --> 00:47:50,260
提交命令你知道这个动物园管理员
commit command you know this zookeepers

977
00:47:50,260 --> 00:47:52,180
应用程序与先将其放入筏子的方式相同
app as much the same as raft it first

978
00:47:52,180 --> 00:47:54,339
发送日志条目，然后当
sends out a log entry and then when the

979
00:47:54,339 --> 00:47:55,780
领导人获得了大多数积极的支持
leader gets a majority of positive

980
00:47:55,780 --> 00:47:57,220
作为回答，领导发出了一个
replies the leader sends out a

981
00:47:57,220 --> 00:47:58,930
通知说是的我要
notification saying yeah I'm gonna

982
00:47:58,930 --> 00:48:01,150
提交我可能没有的日志条目
committing that log entry I may not have

983
00:48:01,150 --> 00:48:03,280
得到了承诺和最糟糕的情况
gotten the commit and the sort of worst

984
00:48:03,280 --> 00:48:04,540
案例版本，尽管它的
case version of this although its

985
00:48:04,540 --> 00:48:05,920
相当于我已经说过的是
equivalent to what I already said is

986
00:48:05,920 --> 00:48:08,650
对于所有客户端和所有客户端
that for all this client for all client

987
00:48:08,650 --> 00:48:14,349
要知道此复制副本可能已分区
to knows this replica may be partitioned

988
00:48:14,349 --> 00:48:16,000
从领导那里，或者仅仅是绝对的
from the leader or may just absolutely

989
00:48:16,000 --> 00:48:17,859
与领导完全没有联系，
not be in contact with leader at all and

990
00:48:17,859 --> 00:48:19,690
你知道追随者并不是真的
you know the follower doesn't really

991
00:48:19,690 --> 00:48:20,980
有办法知道
have a way of knowing

992
00:48:20,980 --> 00:48:23,500
实际上它刚刚被切断了一个
that actually it's just been cut off a

993
00:48:23,500 --> 00:48:25,720
刚刚从领导那里发来的，只是不是
moment ago from the leader and just not

994
00:48:25,720 --> 00:48:29,230
得到任何东西，这样你就不需要知道了
getting anything so you know without

995
00:48:29,230 --> 00:48:32,619
如果我们想要更聪明的话
some further cleverness if we want to

996
00:48:32,619 --> 00:48:35,020
建立一个我们不能线性化的系统
build a linearizable system we can't

997
00:48:35,020 --> 00:48:37,000
玩这个游戏把有吸引力的
play this game of sending the attractive

998
00:48:37,000 --> 00:48:38,829
就目前的表现而言，我们不能
it as it is for performance we can't

999
00:48:38,829 --> 00:48:40,210
在复制件上玩这个游戏，发送一个
play this game at replicas sending a

1000
00:48:40,210 --> 00:48:43,570
对复制副本的读取请求，并且您
read request to the replicas and you

1001
00:48:43,570 --> 00:48:44,920
实验3也不应该这样做，因为
shouldn't do it for lab 3 either because

1002
00:48:44,920 --> 00:48:47,020
这3个也应该是
that 3 is also supposed to be

1003
00:48:47,020 --> 00:48:53,440
可以线性化，任何问题都可以
linearizable it's any any questions

1004
00:48:53,440 --> 00:48:57,579
关于为什么线性化能力禁止我们
about why linearize ability forbids us

1005
00:48:57,579 --> 00:49:02,890
让副本为客户端提供服务可以
from having replicas serve clients ok

1006
00:49:02,890 --> 00:49:07,690
你知道证据就是我把它弄丢了
you know that the proof is the I lost it

1007
00:49:07,690 --> 00:49:11,250
但是证据就是这么简单
now but the proof was that simple

1008
00:49:11,400 --> 00:49:13,990
阅读你知道的正确的一个正确的阅读
reading you know right one right to read

1009
00:49:13,990 --> 00:49:16,980
我早些时候在黑板上举了一个例子
one example I put on the board earlier

1010
00:49:16,980 --> 00:49:19,900
你不是很多，只是你知道这不是
you not a lot just you know this is not

1011
00:49:19,900 --> 00:49:21,070
中的陈旧数据提供服务。
allowed to serve stale data in the

1012
00:49:21,070 --> 00:49:28,119
线性可线性化系统可以，那么怎么做呢？
linear linearizable system ok so how

1013
00:49:28,119 --> 00:49:29,619
哦，那我们的交易是怎么做的呢？
does how does ooh keep our deal with

1014
00:49:29,619 --> 00:49:31,180
这位动物园管理员真的做得到吗？
this zookeeper actually does you can

1015
00:49:31,180 --> 00:49:33,040
从表2可以看出您在表中查找
tell from table two you look in Table

1016
00:49:33,040 --> 00:49:35,470
两名动物园管理员阅读性能上升
two zookeepers read performance goes up

1017
00:49:35,470 --> 00:49:38,020
随着您添加更多服务器，
dramatically as you add more servers so

1018
00:49:38,020 --> 00:49:39,790
显然动物园管理员在玩游戏
clearly zookeepers playing some game

1019
00:49:39,790 --> 00:49:41,650
这里允许的必须是允许它
here which allows must be allowing it to

1020
00:49:41,650 --> 00:49:44,380
返回只读以提供只读服务
return read only to serve read only

1021
00:49:44,380 --> 00:49:46,869
来自其他服务器的请求
requests from the additional servers the

1022
00:49:46,869 --> 00:49:50,050
那么Ooh Keeper是如何制作复制品的呢？
replicas so how does ooh keeper make

1023
00:49:50,050 --> 00:49:52,410
这个保险箱
this safe

1024
00:49:59,010 --> 00:50:01,060
是的，我的意思是，实际上它几乎是
that's right I mean in fact it's almost

1025
00:50:01,060 --> 00:50:02,200
不允许说它确实需要
not allowed to say it does need the

1026
00:50:02,200 --> 00:50:05,110
最近写的，是的，动物园管理员的方式
written latest yeah the way zookeeper

1027
00:50:05,110 --> 00:50:06,580
剥了这只猫的皮就是它不是
skins this cat is that it's not

1028
00:50:06,580 --> 00:50:09,340
可线性化的权利，他们只是喜欢
linearizable right they just like to

1029
00:50:09,340 --> 00:50:10,690
找出这个问题并说好
find away this problem and say well

1030
00:50:10,690 --> 00:50:12,220
我们不会的我们不会的
we're not gonna be we're not going to

1031
00:50:12,220 --> 00:50:14,500
提供可线性化读取等功能
provide linearizable reads and so

1032
00:50:14,500 --> 00:50:17,470
所以你没有义务
therefore you don't are not obliged

1033
00:50:17,470 --> 00:50:20,230
你知道动物园管理员没有义务
you know zookeepers not obliged to

1034
00:50:20,230 --> 00:50:23,950
提供允许读取的最新数据
provide fresh data to reads it's allowed

1035
00:50:23,950 --> 00:50:25,690
根据它的一致性规则，这些规则是
by its rules of consistency which are

1036
00:50:25,690 --> 00:50:28,510
不能线性化以产生陈旧数据
not linearizable to produce stale data

1037
00:50:28,510 --> 00:50:31,720
对惠顿来说，所以它在某种程度上已经解决了
for Wheaton's so it's sort of solved

1038
00:50:31,720 --> 00:50:33,900
这个技术问题是一种
this technical problem with a kind of

1039
00:50:33,900 --> 00:50:37,300
魔杖的定义波通过说
definitional wave of the wand by saying

1040
00:50:37,300 --> 00:50:38,830
嗯，我们从来不欠你可线性化的东西。
well we never owed you them linearizable

1041
00:50:38,830 --> 00:50:41,170
它会被放在第一位，所以它不是
it'll be in the first place so it's not

1042
00:50:41,170 --> 00:50:45,760
如果你不提供它，那就是一个错误，那就是
a bug if you don't provide it and that's

1043
00:50:45,760 --> 00:50:46,870
实际上，这是一种非常经典的方式
actually a pretty classic way to

1044
00:50:46,870 --> 00:50:49,900
以此来接近某种
approach this to approach the sort of

1045
00:50:49,900 --> 00:50:53,620
履约与严格之间的紧张关系
tension between performance and strict

1046
00:50:53,620 --> 00:50:55,990
而强烈的一致性就是不
and strong consistency is to just not

1047
00:50:55,990 --> 00:50:58,180
尽管如此，仍然提供了很强的一致性
provide strong consistency nevertheless

1048
00:50:58,180 --> 00:51:00,250
我们必须把我们的思想放在心底
we have to keep in the back of our minds

1049
00:51:00,250 --> 00:51:03,760
如果系统没有
question of if the system doesn't

1050
00:51:03,760 --> 00:51:07,300
提供线性化能力还是它
provide linearize ability is it still

1051
00:51:07,300 --> 00:51:09,520
会很有用，对吧，你做一个
going to be useful right and you do a

1052
00:51:09,520 --> 00:51:11,380
读一读，你就不会明白当前的潮流
read and you just don't get the current

1053
00:51:11,380 --> 00:51:12,700
答案或当前正确答案
answer or current correct answer the

1054
00:51:12,700 --> 00:51:14,590
最新的数据，比如我们为什么认为
most latest data like why do we believe

1055
00:51:14,590 --> 00:51:16,270
这将产生一个有用的
that that's gonna produce a useful

1056
00:51:16,270 --> 00:51:22,780
系统，所以让我来谈谈这一点
system and so let me talk about that so

1057
00:51:22,780 --> 00:51:26,440
首先，有没有任何关于
first of all any questions about about

1058
00:51:26,440 --> 00:51:28,480
动物园管理员真正要做的基本问题是
the basic problem zookeeper really does

1059
00:51:28,480 --> 00:51:30,460
允许客户端发送只读请求
allow client to send read-only requests

1060
00:51:30,460 --> 00:51:33,490
发送到任何复制副本，并且该复制副本响应
to any replica and the replica responds

1061
00:51:33,490 --> 00:51:35,380
从它目前的状态中解脱出来
out of its current state and that

1062
00:51:35,380 --> 00:51:37,210
复制可能滞后，其日志可能
replicate may be lagging it's log may

1063
00:51:37,210 --> 00:51:39,220
没有最新的日志条目，并且
not have the very latest log entries and

1064
00:51:39,220 --> 00:51:42,520
因此它可能会返回过时数据，即使
so it may return stale data even though

1065
00:51:42,520 --> 00:51:46,200
有一个更新的承诺价值
there's a more recent committed value

1066
00:51:46,650 --> 00:51:51,780
好的，那么我们还剩下什么呢？
okay so what are we left with

1067
00:51:51,780 --> 00:51:55,990
动物园管理员确实有一些它
zookeeper does actually have some it

1068
00:51:55,990 --> 00:51:57,670
确实有一套一致性
does have a set of consistency

1069
00:51:57,670 --> 00:52:01,180
保证这样做是为了帮助那些写作的人
guarantees so to help people who write

1070
00:52:01,180 --> 00:52:02,980
基于ZooKeeper的应用程序原因
zookeeper based applications reason

1071
00:52:02,980 --> 00:52:04,540
关于他们的应用程序是什么
about what their applications what's

1072
00:52:04,540 --> 00:52:05,650
实际上会发生在他们奔跑的时候
actually going to happen when they run

1073
00:52:05,650 --> 00:52:07,770
他们是这样的
them so

1074
00:52:07,770 --> 00:52:09,270
而这些担保都与
and these guarantees have to do with

1075
00:52:09,270 --> 00:52:10,980
排序为真正的线性化能力
ordering as indeed linearise ability

1076
00:52:10,980 --> 00:52:15,300
是这样吗？动物园管理员确实有两个主要的
does so zookeeper does have two main

1077
00:52:15,300 --> 00:52:17,990
保证他们声明这是
guarantees that they state and this is

1078
00:52:17,990 --> 00:52:22,400
第2.3节其中一条是不是说
section 2.3 one of them is it says that

1079
00:52:22,400 --> 00:52:33,839
权利或现在可以线性化的权利
rights rights or linearizable now you

1080
00:52:33,839 --> 00:52:34,980
我知道有可线性化的概念
know there are notion of linearizable

1081
00:52:34,980 --> 00:52:37,650
可能和我的不太一样
isn't not quite the same in mine maybe

1082
00:52:37,650 --> 00:52:40,440
因为他们在谈论权利不
because they're talking about rights no

1083
00:52:40,440 --> 00:52:43,589
珠子他们在这里的真正意思是
beads what they really mean here is that

1084
00:52:43,589 --> 00:52:48,300
系统的行为就好像即使
the system behaves as if even though

1085
00:52:48,300 --> 00:52:50,390
客户端可以并发提交权限
clients might submit rights concurrently

1086
00:52:50,390 --> 00:52:52,890
尽管如此，系统的行为就好像它
nevertheless the system behaves as if it

1087
00:52:52,890 --> 00:52:55,230
中一次执行一个权限。
executes the rights one at a time in

1088
00:52:55,230 --> 00:52:59,490
一些顺序，且确实服从实时
some order and indeed obeys real-time

1089
00:52:59,490 --> 00:53:01,020
权利的排序，因此如果一项权利具有
ordering of right so if one right has

1090
00:53:01,020 --> 00:53:03,270
被视为先于另一人完成
seen to have completed before another

1091
00:53:03,270 --> 00:53:05,310
权利已经下达，那么做保管人遗嘱
right has issued then do keeper will

1092
00:53:05,310 --> 00:53:07,320
实际上，它的行为就像它执行了第二个
indeed act as if it executed the second

1093
00:53:07,320 --> 00:53:09,990
就在第一个右转弯之后，所以它是
right after the first right so it's

1094
00:53:09,990 --> 00:53:12,920
权限但不是读取是可线性化的
rights but not reads are linearizable

1095
00:53:12,920 --> 00:53:17,220
动物园看守人并不是一个严格的读写人
and zookeeper isn't a strict readwrite

1096
00:53:17,220 --> 00:53:20,089
系统中实际上有一些权利
system there are actually rights that

1097
00:53:20,089 --> 00:53:23,220
也隐含着阅读，对于那些类型的
imply reads also and for those sort of

1098
00:53:23,220 --> 00:53:26,670
混合权利，那些你认识的人
mixed rights those those you know any

1099
00:53:26,670 --> 00:53:29,490
任何修改状态的操作都是
any operation that modifies the state is

1100
00:53:29,490 --> 00:53:31,140
相对于所有其他
linearizable with respect to all other

1101
00:53:31,140 --> 00:53:37,320
修改状态的操作
operations that modify the state the

1102
00:53:37,320 --> 00:53:42,660
给予的其他保证是任何
other guarantee of gives is that any

1103
00:53:42,660 --> 00:53:47,250
给定客户端，其操作在
given client its operations executes in

1104
00:53:47,250 --> 00:53:49,560
客户端指定的顺序
the order specified by the client

1105
00:53:49,560 --> 00:53:54,800
他们称之为先进先出客户订单
they call that FIFO client order

1106
00:53:56,119 --> 00:53:58,110
这意味着如果一个
and what this means is that if a

1107
00:53:58,110 --> 00:54:00,450
特定客户发布权限并
particular client issues a right and

1108
00:54:00,450 --> 00:54:02,220
然后是读，然后是读，然后是右
then a read and then a read and a right

1109
00:54:02,220 --> 00:54:05,880
或者不管是什么，最重要的权利
or whatever that first of all the rights

1110
00:54:05,880 --> 00:54:09,990
从适合客户端序列
from that sequence fit in in the client

1111
00:54:09,990 --> 00:54:13,110
按以下总体顺序指定顺序
specified order in the overall order of

1112
00:54:13,110 --> 00:54:15,960
所有客户的权利，所以如果客户说
all clients rights so if a client says

1113
00:54:15,960 --> 00:54:18,150
做好这件事，然后做好那件事，然后
do this right then that right and the

1114
00:54:18,150 --> 00:54:21,140
最后权利顺序中的第三权利
third right in the final order of rights

1115
00:54:21,140 --> 00:54:24,210
将看到客户端速率出现在
will see the clients rates occur in the

1116
00:54:24,210 --> 00:54:26,280
为此指定的客户的顺序
order of the client specified so for

1117
00:54:26,280 --> 00:54:32,340
这是我们的客户指定的权利
rights this is our client specified

1118
00:54:32,340 --> 00:54:38,310
订单，这是特别的，你知道的
order and this is particularly you know

1119
00:54:38,310 --> 00:54:40,920
这是系统的一个问题，因为
this is a issue with the system because

1120
00:54:40,920 --> 00:54:41,880
允许客户端启动
clients are allowed to launch

1121
00:54:41,880 --> 00:54:44,610
异步权限请求，该请求是
asynchronous right requests that is a

1122
00:54:44,610 --> 00:54:46,290
客户端可以发出一系列完整的
client can fire off a whole sequence of

1123
00:54:46,290 --> 00:54:49,140
领队对动物园管理员的权利
rights to the leader to the zookeeper

1124
00:54:49,140 --> 00:54:51,060
领队，不用等他们中的任何一个
leader without waiting for any of them

1125
00:54:51,060 --> 00:54:53,970
要完成并按顺序恢复
to complete and in order resume the

1126
00:54:53,970 --> 00:54:55,500
报纸上并没有明确写到这一点，但是
paper doesn't exactly say this but

1127
00:54:55,500 --> 00:54:57,480
想必是为了让领导人
presumably in order for the leader to

1128
00:54:57,480 --> 00:54:59,580
实际上能够执行客户端
actually be able to execute the clients

1129
00:54:59,580 --> 00:55:00,930
客户端指定顺序中的权限
rights in the client specified order

1130
00:55:00,930 --> 00:55:03,300
我们在想象我在想象
we're imagining I'm imagining that the

1131
00:55:03,300 --> 00:55:04,920
客户端实际标记其写入
client actually stamps its write

1132
00:55:04,920 --> 00:55:07,680
有数字的请求，并说你
requests with numbers and saying you

1133
00:55:07,680 --> 00:55:08,910
我知道我会先做这件事，这件事
know I'll do this one first this one

1134
00:55:08,910 --> 00:55:11,670
第二，这三分之一和动物园管理员
second this one third and the zookeeper

1135
00:55:11,670 --> 00:55:14,310
领导服从命令的权利，所以这是
leader obeys that ordering right so this

1136
00:55:14,310 --> 00:55:15,810
特别有趣，因为这些
is particularly interesting due to these

1137
00:55:15,810 --> 00:55:19,170
异步写入请求和用于
asynchronous write requests and for

1138
00:55:19,170 --> 00:55:25,670
读起来这有点复杂
reads this is a little more complicated

1139
00:55:25,670 --> 00:55:27,990
我之前说的理由不会消失
the reasons I said before don't go

1140
00:55:27,990 --> 00:55:29,280
通过所有写入都通过
through the writes all go through the

1141
00:55:29,280 --> 00:55:31,470
领队读书会刚刚去了一些
leader the reads just go to some

1142
00:55:31,470 --> 00:55:33,359
复制品，所以他们看到的只有
replicas and so all they see is the

1143
00:55:33,359 --> 00:55:35,220
那些碰巧被送到这里的东西
stuff that happens to have made it to

1144
00:55:35,220 --> 00:55:38,280
那些复制品以我们应该记录的方式记录
that replicas log the way we're supposed

1145
00:55:38,280 --> 00:55:41,520
要考虑FIFO客户订单，请执行以下操作
to think about the FIFO client order for

1146
00:55:41,520 --> 00:55:43,650
读取的情况是，如果客户端发出
reads is that if the client issues a

1147
00:55:43,650 --> 00:55:45,690
按某种顺序再次读取的顺序
sequence of reads again in some order

1148
00:55:45,690 --> 00:55:47,340
客户读到一件事，然后
the client reads one thing and then

1149
00:55:47,340 --> 00:55:48,359
另一件事，然后是第三件事
another thing and then a third thing

1150
00:55:48,359 --> 00:55:53,490
相对于复制副本上的日志
that relative to the log on the replicas

1151
00:55:53,490 --> 00:55:59,130
与这些客户交谈时，每个读者都有
talking to those clients reads each have

1152
00:55:59,130 --> 00:56:00,960
中的某个特定点发生
to occur at some particular point in the

1153
00:56:00,960 --> 00:56:05,220
日志，否则他们需要在某种程度上观察
log or they need to sort of observe the

1154
00:56:05,220 --> 00:56:07,740
状态，因为该状态存在于
state as it as the state existed at a

1155
00:56:07,740 --> 00:56:08,549
特定点
particular point

1156
00:56:08,549 --> 00:56:11,279
日志，此外，
the log and furthermore that the

1157
00:56:11,279 --> 00:56:14,699
连续读取必须观察点
successive reads have to observe points

1158
00:56:14,699 --> 00:56:17,189
不会倒退，也就是说，如果一个
that don't go backwards that is if a

1159
00:56:17,189 --> 00:56:18,749
客户端发出一次读取，然后发出另一次读取
client issues one read and then another

1160
00:56:18,749 --> 00:56:20,369
读取，第一次读取在此执行
read and the first read executes at this

1161
00:56:20,369 --> 00:56:21,929
在日志中第二次读取的指针是
point in the log the second read is that

1162
00:56:21,929 --> 00:56:24,779
你知道被允许以同样的方式执行它
you know allowed to execute it the same

1163
00:56:24,779 --> 00:56:26,519
或日志中稍后的点，但不是
or later points in the log but not

1164
00:56:26,519 --> 00:56:29,789
允许按问题查看以前的状态
allowed to see a previous state by issue

1165
00:56:29,789 --> 00:56:30,959
一次读取，然后另一次读取
one read and then another read the

1166
00:56:30,959 --> 00:56:32,819
第二次读取必须查看处于以下位置的状态
second read has to see a state that's at

1167
00:56:32,819 --> 00:56:34,859
至少与第一个州一样最新
least as up-to-date as the first state

1168
00:56:34,859 --> 00:56:41,160
这是一个重要的事实
and that's a significant fact in that

1169
00:56:41,160 --> 00:56:43,019
我们要在推理的时候驾驭
we're gonna harness when we're reasoning

1170
00:56:43,019 --> 00:56:45,809
关于如何写正确的动物园管理员
about how to write correct zookeeper

1171
00:56:45,809 --> 00:56:47,729
应用程序及其位置
applications and where this is

1172
00:56:47,729 --> 00:56:50,489
特别令人兴奋的是，如果
especially exciting is that if the

1173
00:56:50,489 --> 00:56:52,109
客户端正在与一个复制副本对话，以获取
client is talking to one replica for a

1174
00:56:52,109 --> 00:56:54,299
同时，它会向以下对象发出一些读取问题
while and it issues some reads issue to

1175
00:56:54,299 --> 00:56:56,729
读这里，然后我读那里，如果这是
read here and then I read there if this

1176
00:56:56,729 --> 00:56:59,069
复制副本失败，客户端需要
replica fails and the client needs to

1177
00:56:59,069 --> 00:57:00,269
开始将其读取发送到另一个
start sending its read to another

1178
00:57:00,269 --> 00:57:03,900
保证此FIFO客户端的副本
replica that guaranteed this FIFO client

1179
00:57:03,900 --> 00:57:07,140
或者担保仍然有效，如果客户
or a guarantee still holds if the client

1180
00:57:07,140 --> 00:57:08,999
切换到新的复制副本，因此
switches to a new replica and so that

1181
00:57:08,999 --> 00:57:10,679
意思是如果你在坠机前就知道
means that if you know before a crash

1182
00:57:10,679 --> 00:57:13,049
客户读了一遍那种锯子
the client did a read that sort of saw

1183
00:57:13,049 --> 00:57:16,769
在日志中的这一点上声明
state as of this point in the log that

1184
00:57:16,769 --> 00:57:18,119
意味着客户希望新的
means when the clients wishes to the new

1185
00:57:18,119 --> 00:57:20,910
复制副本，如果它向您发出另一次读取
replicas if it issues another read you

1186
00:57:20,910 --> 00:57:22,709
知道这是它之前执行的读取
know it's its previous read executed

1187
00:57:22,709 --> 00:57:23,189
这里
here

1188
00:57:23,189 --> 00:57:25,559
如果客户端发出另一次读取，
if a client issues another read that

1189
00:57:25,559 --> 00:57:27,089
Read必须在此时执行，否则
read has to execute at this point or

1190
00:57:27,089 --> 00:57:29,599
后来即使它交换了复制品
later even though it's switched replicas

1191
00:57:29,599 --> 00:57:32,519
你知道这件事的运作方式是
and you know the way this works is that

1192
00:57:32,519 --> 00:57:35,789
这些日志条目中的每一个都由
each of these log entries is tagged by

1193
00:57:35,789 --> 00:57:39,719
引导者使用Z X ID对其进行标记，该ID
the leader tags it with a Z X ID which

1194
00:57:39,719 --> 00:57:42,079
基本上只是一个条目编号
is basically just a entry number

1195
00:57:42,079 --> 00:57:45,390
每当复制副本响应客户端时
whenever a replica responds to a client

1196
00:57:45,390 --> 00:57:47,849
读请求，您知道它执行了
read request it you know executed the

1197
00:57:47,849 --> 00:57:49,349
在特定点请求，并且
request at a particular point and the

1198
00:57:49,349 --> 00:57:52,979
复制副本使用以下项的Z X ID进行响应
replica responds with the Z X ID of the

1199
00:57:52,979 --> 00:57:54,599
紧挨着之前的日志条目返回到
immediately preceding log entry back to

1200
00:57:54,599 --> 00:57:57,239
客户端记得的客户端是
the client the client remembers this was

1201
00:57:57,239 --> 00:58:00,420
您的最新数据的EXID
the exid of the most recent data you

1202
00:58:00,420 --> 00:58:01,859
知道是我见过的最高的zx点子
know is the highest z x idea i've ever

1203
00:58:01,859 --> 00:58:04,829
在客户端发送请求时看到
seen and when the client sends a request

1204
00:58:04,829 --> 00:58:07,499
复制到相同或不同的复制副本
to the same or a different replica it

1205
00:58:07,499 --> 00:58:09,779
随之而来的是他们的要求
accompanies their request with that

1206
00:58:09,779 --> 00:58:11,729
有史以来最高的CX ID
highest CX ID has ever seen and that

1207
00:58:11,729 --> 00:58:14,160
告诉另一个复制品啊哈你知道我
tells this other replica aha you know i

1208
00:58:14,160 --> 00:58:16,679
需要通过以下方式响应该请求
need to respond to that request with

1209
00:58:16,679 --> 00:58:19,679
至少与此相关的数据
data that's at least relative to this

1210
00:58:19,679 --> 00:58:21,190
在日志中指向
point in a log

1211
00:58:21,190 --> 00:58:22,839
这很有趣，如果你知道的话
and that's interesting if this you know

1212
00:58:22,839 --> 00:58:25,089
此复制副本不在第二个复制副本上
this replicas not up this second replica

1213
00:58:25,089 --> 00:58:28,000
更不是最新的，是的，那时候是的
is even less up to date yes was then

1214
00:58:28,000 --> 00:58:29,920
接收到其中的任何一个，但它接收到一个
received any of these but it receives a

1215
00:58:29,920 --> 00:58:31,270
客户的请求客户说哦
request from a client the client says oh

1216
00:58:31,270 --> 00:58:34,630
天哪，我上次读的时候执行了这个
gosh the last read I did executed this

1217
00:58:34,630 --> 00:58:36,339
日志和其他一些复制副本中的点
spot in the log and some other replica

1218
00:58:36,339 --> 00:58:38,950
此复制副本需要等待，直到它
this replica needs to wait until it's

1219
00:58:38,950 --> 00:58:41,289
将整个日志记录到这一点
gotten the entire log up to this point

1220
00:58:41,289 --> 00:58:42,819
在它被允许响应
before it's allowed to respond to the

1221
00:58:42,819 --> 00:58:46,539
客户，我不太清楚这是怎么回事
client and I'm not sure exactly how that

1222
00:58:46,539 --> 00:58:48,309
工作，但要么复制品只是
works but either the replicas just

1223
00:58:48,309 --> 00:58:51,069
延迟对读取的响应，或者可能
delays responding to the read or maybe

1224
00:58:51,069 --> 00:58:52,510
它拒绝阅读并说，你看，我只是
it rejects the read and says look I just

1225
00:58:52,510 --> 00:58:53,770
不知道谈话的信息
don't know the information talk to

1226
00:58:53,770 --> 00:58:55,059
其他人或者以后再跟我说
somebody else or talk to me later

1227
00:58:55,059 --> 00:58:57,280
你知道这个最终会在哪里
where's eventually the you know this

1228
00:58:57,280 --> 00:58:59,289
如果已连接，复本将会赶上
replica will catch up if it's connected

1229
00:58:59,289 --> 00:59:01,210
给领导，然后你就不能
to the leader and then you won't be able

1230
00:59:01,210 --> 00:59:03,630
回应
to respond

1231
00:59:04,119 --> 00:59:06,730
好的，所以阅读是有序的，他们只会
okay so reads are ordered they only go

1232
00:59:06,730 --> 00:59:08,950
在时间上前进或仅在时间内前进
forward in time or only go forward in

1233
00:59:08,950 --> 00:59:12,670
一种日志顺序，还有一件事
sort of log order and a further thing

1234
00:59:12,670 --> 00:59:14,140
我相信这是关于理性的真理
which I believe is true about reason

1235
00:59:14,140 --> 00:59:18,039
权限是读写FIFO
rights is that reads and writes the FIFO

1236
00:59:18,039 --> 00:59:20,380
客户订单适用于所有客户
client order applies to all of a clients

1237
00:59:20,380 --> 00:59:22,750
所有单个客户端都请求，因此如果我
all of a single clients requests so if I

1238
00:59:22,750 --> 00:59:25,359
从客户端进行写入，然后我发送一个
do a write from a client and I send a

1239
00:59:25,359 --> 00:59:28,210
给领导写信需要时间
write to the leader it takes time before

1240
00:59:28,210 --> 00:59:29,829
该写入已提交发送
that write is sent out committed

1241
00:59:29,829 --> 00:59:31,359
不管怎样，我可以把它直接寄给
whatever so I may send it right to the

1242
00:59:31,359 --> 00:59:33,099
领队领队没有处理它或
leader the leader hasn't processed it or

1243
00:59:33,099 --> 00:59:36,660
已经提交了，然后我发送了一个读取器
committed it yet and then I send a read

1244
00:59:36,660 --> 00:59:39,789
对于复制副本，读取可能必须停止
to a replica the read may have to stall

1245
00:59:39,789 --> 00:59:41,740
你知道为了保证先进先出
you know in order to guarantee FIFO

1246
00:59:41,740 --> 00:59:43,779
客户订购读数，他们必须
client order the read and they have to

1247
00:59:43,779 --> 00:59:45,910
拖延到此客户端实际
stall until this client has actually

1248
00:59:45,910 --> 00:59:48,730
查看并执行了以前的
seen and executed the previous the

1249
00:59:48,730 --> 00:59:52,029
客户端的上一次写入操作So
client's previous write operation so

1250
00:59:52,029 --> 00:59:53,980
那是这种类型的
that's a consequence of this type of

1251
00:59:53,980 --> 00:59:55,930
客户订单是权利被
client order is that a reason rights are

1252
00:59:55,930 --> 00:59:58,119
同样的顺序，你知道怎么走
in the same order and you know the way

1253
00:59:58,119 --> 01:00:00,760
要了解这一点，最明显的方法是如果一个
the most obvious way to see this is if a

1254
01:00:00,760 --> 01:00:03,400
客户端写入特定数据段
client writes a particular piece of data

1255
01:00:03,400 --> 01:00:05,650
你知道吗，给领导写封信
you know sends a write to the leader and

1256
01:00:05,650 --> 01:00:07,690
然后立即读取相同的
then immediately does a read of the same

1257
01:00:07,690 --> 01:00:09,430
并将读取数据发送到
piece of data and sends that read to a

1258
01:00:09,430 --> 01:00:11,680
复制品男孩，它最好看看它自己
replica boy it better see its own

1259
01:00:11,680 --> 01:00:13,450
如果我写了什么东西，写的值是对的
written value right if I write something

1260
01:00:13,450 --> 01:00:16,359
值为17，然后我做了一个读数
to have value 17 and then I do a read

1261
01:00:16,359 --> 01:00:18,970
它没有价值17，那就是
and it doesn't have value 17 then that's

1262
01:00:18,970 --> 01:00:21,670
太离奇了，这是天哪的证据
just bizarre and it's evidence that gosh

1263
01:00:21,670 --> 01:00:23,740
系统没有执行我的请求
the system was not executing my requests

1264
01:00:23,740 --> 01:00:25,299
因为那样它就会
in order because then it would have

1265
01:00:25,299 --> 01:00:27,220
执行写入，然后在
executed the write and then before the

1266
01:00:27,220 --> 01:00:29,319
读一读，所以一定有一些有趣的东西
read so there must be some funny

1267
01:00:29,319 --> 01:00:31,450
复制品业务停滞不前
business with the replicas stalling

1268
01:00:31,450 --> 01:00:33,670
客户端在发送读取和
the client must when it sends a read and

1269
01:00:33,670 --> 01:00:35,559
说，看，你知道我写的最后一封信
say look you know I the last write

1270
01:00:35,559 --> 01:00:37,269
请求我发送了一位具有ZX ID的领导
request I sent a leader with ZX ID

1271
01:00:37,269 --> 01:00:39,730
此复制品中的某些内容必须等待
something in this replica has to wait

1272
01:00:39,730 --> 01:00:44,640
直到它看到我是领导者是的
till it sees that I'm the leader yes

1273
01:00:53,660 --> 01:00:56,390
哦，当然了，所以我想你是什么
oh absolutely so I think what you're

1274
01:00:56,390 --> 01:00:58,250
据观察，从复制副本读取
observing is that a read from a replica

1275
01:00:58,250 --> 01:01:00,880
可能看不到最新数据，因此
may not see the latest data so the

1276
01:01:00,880 --> 01:01:03,650
领袖可能已经向多数派发出了C
leader may have sent out C to a majority

1277
01:01:03,650 --> 01:01:06,890
复制副本，并提交它和
of replicas and committed it and the

1278
01:01:06,890 --> 01:01:08,930
大多数人可能已经执行了，但是如果我们的
majority may have executed it but if our

1279
01:01:08,930 --> 01:01:10,640
我们说的复制品不在里面
replica that we're talking wasn't in

1280
01:01:10,640 --> 01:01:12,710
大多数人可能这个复制品没有
that majority maybe this replica doesn't

1281
01:01:12,710 --> 01:01:14,119
有最新的数据，那就是
have the latest data and that just is

1282
01:01:14,119 --> 01:01:17,900
动物园管理员的工作方式，它确实是这样做的
the way zoo keeper works and so it does

1283
01:01:17,900 --> 01:01:20,329
不能保证我们会看到最新的
not guarantee that we'd see the latest

1284
01:01:20,329 --> 01:01:23,900
所以如果有保证的话
data so if there there is a guarantee

1285
01:01:23,900 --> 01:01:25,339
关于ReadWrite排序，但它只是
about readwrite ordering but it's only

1286
01:01:25,339 --> 01:01:28,849
每个客户端，因此如果我发送写入并
per client so if I send a write in and

1287
01:01:28,849 --> 01:01:31,880
然后我把数据读入系统
then I read that data the system

1288
01:01:31,880 --> 01:01:34,069
保证我的珠子遵守我的
guarantees that my bead observes my

1289
01:01:34,069 --> 01:01:37,039
好的，如果你发一个右拳，然后我
right if you send a right in and then I

1290
01:01:37,039 --> 01:01:39,920
阅读你写的数据这不是
read the data that you wrote this isn't

1291
01:01:39,920 --> 01:01:43,029
不能保证我看到你的权利
does not guarantee that I see your right

1292
01:01:43,029 --> 01:01:46,069
你知道这就像是
and that's and you know that's like the

1293
01:01:46,069 --> 01:01:50,119
他们如何获得加速的基础
foundation of how they get speed up for

1294
01:01:50,119 --> 01:01:51,470
读数与
reads proportional to the number of

1295
01:01:51,470 --> 01:01:53,890
复制品
replicas

1296
01:01:58,560 --> 01:02:00,900
但我要说的是，这个系统不是
but I would say the system isn't

1297
01:02:00,900 --> 01:02:04,560
可线性化，但它不是那样的
linearizable and and but it is not that

1298
01:02:04,560 --> 01:02:07,080
它没有属性，则权利是
it has no properties then the rights are

1299
01:02:07,080 --> 01:02:09,120
当然有很多好的，所有的权利都来自
certainly many all right all rights from

1300
01:02:09,120 --> 01:02:11,790
所有客户一次形成一个客户
all clients form some one at a time

1301
01:02:11,790 --> 01:02:13,950
序列，所以这是一种意义上的
sequence so that's a sense in which the

1302
01:02:13,950 --> 01:02:16,170
权利所有的权利都是可笑的膝盖
rights all rights are the knee risible

1303
01:02:16,170 --> 01:02:21,260
和每个单独的客户端操作
and each individual clients operations

1304
01:02:21,260 --> 01:02:27,000
可能这意味着它也是可线性化的
may be this means linearizable also it

1305
01:02:27,000 --> 01:02:29,340
你知道吗，这可能意味着
may you know this this probably means

1306
01:02:29,340 --> 01:02:31,050
每个单独的客户操作
that each individual clients operations

1307
01:02:31,050 --> 01:02:32,280
线性化得很好，虽然我还不是很清楚
are linearize well though I'm not quite

1308
01:02:32,280 --> 01:02:48,810
当然你知道我其实不知道怎么做
sure you know I'm actually not sure how

1309
01:02:48,810 --> 01:02:50,820
它是有效的，但这是合理的
it works but that's a reasonable

1310
01:02:50,820 --> 01:02:52,200
那么假设当我发送一个
supposition then when I send in an

1311
01:02:52,200 --> 01:02:54,660
异步权限，系统不会
asynchronous right the system doesn't

1312
01:02:54,660 --> 01:02:56,190
尚未执行，但它确实回复了我
execute it yet but it does reply to me

1313
01:02:56,190 --> 01:02:57,270
说，是的，你知道我有你的权利
saying yeah you know I got your right

1314
01:02:57,270 --> 01:02:59,070
这是这个牦牛的身份证，它会
and here's this yaks ID that it will

1315
01:02:59,070 --> 01:03:03,090
如果它被承诺了，我只想开始
have if it's committed I just like start

1316
01:03:03,090 --> 01:03:04,920
返回所以这是一个合理的理论
return so that's a reasonable theory I

1317
01:03:04,920 --> 01:03:06,360
我不知道它是怎么做到的
don't actually know how it does it and

1318
01:03:06,360 --> 01:03:11,040
如果客户端不阅读，则它需要
then the client if it doesn't read needs

1319
01:03:11,040 --> 01:03:12,330
为了让复制品看起来像你知道的
to tell the replicas look you know

1320
01:03:12,330 --> 01:03:31,830
是的，我做了，你知道，如果我做一个
that's right I did you know if I do a

1321
01:03:31,830 --> 01:03:42,030
数据的读取是操作的一部分
read of the data is of the operation

1322
01:03:42,030 --> 01:03:43,740
好的，如果您将读取发送到复制副本
okay so if you send a read to a replica

1323
01:03:43,740 --> 01:03:45,600
作为回报，复制品会让你知道
the replicas in return you that you know

1324
01:03:45,600 --> 01:03:47,310
实际上，这是从这张表中读取的数据
really it's a read from this table is

1325
01:03:47,310 --> 01:03:49,590
什么你不可能名义上是什么
what your no way notionally what the

1326
01:03:49,590 --> 01:03:51,240
客户认为它在这么做，你的客户
client thinks it's doing so you client

1327
01:03:51,240 --> 01:03:52,290
这就是我想读这行的全部内容
says all I want to read this row from

1328
01:03:52,290 --> 01:03:54,390
此复本发送的服务器的此表
this table the server this replica sends

1329
01:03:54,390 --> 01:03:56,310
返回该表当前值
back its current value for that table

1330
01:03:56,310 --> 01:04:00,270
加上上次操作的GX ID
plus the GX ID of the last operation

1331
01:04:00,270 --> 01:04:03,500
更新了该表
that updated that table

1332
01:04:06,570 --> 01:04:10,110
是啊，所以实际上我是我不是
yeah so there's so actually I'm I'm not

1333
01:04:10,110 --> 01:04:13,560
准备好做两件事，那就是
prepared to so the the two things that

1334
01:04:13,560 --> 01:04:14,910
会很有意义，而且我认为这两种情况中的任何一种
would make sense and I think either of

1335
01:04:14,910 --> 01:04:17,340
他们会没事的，因为服务器可以
them would be okay is the server could

1336
01:04:17,340 --> 01:04:20,310
对于每个表行，都要跟踪这一点。
track this yet for every table row the

1337
01:04:20,310 --> 01:04:22,380
最后一个右操作的ZX ID
ZX ID of the last right operation that

1338
01:04:22,380 --> 01:04:25,140
触摸它，或者它可以让所有人都能读到
touched it or it could just to all read

1339
01:04:25,140 --> 01:04:27,870
请求将ZX ID作为最后一个返回
requests returned the ZX ID as a last

1340
01:04:27,870 --> 01:04:29,100
其日志中的已提交操作
committed operation in its log

1341
01:04:29,100 --> 01:04:31,590
不管那是不是最后一次
regardless of whether that was the last

1342
01:04:31,590 --> 01:04:34,110
触摸行操作，因为所有
operation of touch that row because all

1343
01:04:34,110 --> 01:04:36,000
我们要做的就是确保客户
we need to do is make sure that client

1344
01:04:36,000 --> 01:04:38,700
请求按顺序向前移动，因此我们
requests move forward in the order so we

1345
01:04:38,700 --> 01:04:40,170
只是需要一些东西来回报一些东西
just need something to return something

1346
01:04:40,170 --> 01:04:42,540
它大于或等于
that's greater than or equal to the

1347
01:04:42,540 --> 01:04:45,720
对上一次接触到的数据
right that last touched the data that

1348
01:04:45,720 --> 01:04:54,570
客户读得很好，所以这些是
the client read all right so these are

1349
01:04:54,570 --> 01:05:01,440
保证书所以你知道我们还是离开了
the guarantees so you know we still left

1350
01:05:01,440 --> 01:05:02,370
带着一个问题，那就是是否有可能
with a question of whether it's possible

1351
01:05:02,370 --> 01:05:04,980
要对此进行合理的编程，请执行以下操作
to do reasonable programming with this

1352
01:05:04,980 --> 01:05:06,780
一套保证，答案是好的
set of guarantees and the answer is well

1353
01:05:06,780 --> 01:05:08,400
这是你在高层次上知道的，这是
this you know at a high level this is

1354
01:05:08,400 --> 01:05:11,040
不如可线性化的好，它是一个
not quite as good as linearizable it's a

1355
01:05:11,040 --> 01:05:12,330
更难理解的是
little bit harder to reason about and

1356
01:05:12,330 --> 01:05:14,010
有更多的问题，比如阅读
there's sort of more gotchas like reads

1357
01:05:14,010 --> 01:05:15,690
可以返回过时的数据，但不会发生
can return stale data just can't happen

1358
01:05:15,690 --> 01:05:18,510
在一个可线性化的系统中，但是它
in a linearizable system but it's

1359
01:05:18,510 --> 01:05:21,090
尽管如此，好到足以使
nevertheless good enough to do to make

1360
01:05:21,090 --> 01:05:22,800
这是相当直截了当的道理
it pretty straightforward to reason

1361
01:05:22,800 --> 01:05:27,900
关于很多你可能想要做的事情
about a lot of things you might want to

1362
01:05:27,900 --> 01:05:33,990
和动物园管理员一起做，所以有一个，所以我
do with zookeeper so there's a so I'm

1363
01:05:33,990 --> 01:05:35,520
我可能会试着构思一个论点
gonna try to construct an argument maybe

1364
01:05:35,520 --> 01:05:38,040
通过举例说明为什么这不是一个糟糕的
by example of why this is not such a bad

1365
01:05:38,040 --> 01:05:41,130
顺便说一句，编程模型是一个原因
programming model one reason by the way

1366
01:05:41,130 --> 01:05:42,630
就是有一种外在的存在，这就是
is that there's an out there's this

1367
01:05:42,630 --> 01:05:44,160
名为接收器的操作，该接收器
operation called sink which is

1368
01:05:44,160 --> 01:05:47,010
本质上是写操作，如果
essentially a write operation and if a

1369
01:05:47,010 --> 01:05:49,410
客户，你知道的，假设我知道
client you know supposing I know that

1370
01:05:49,410 --> 01:05:51,660
你最近写了一些你是个
you recently wrote something you being a

1371
01:05:51,660 --> 01:05:53,100
不同的客户和我想看什么
different client and I want to read what

1372
01:05:53,100 --> 01:05:54,660
你写的所以我想要最新的数据
you wrote so I actually want fresh data

1373
01:05:54,660 --> 01:05:57,780
我可以送一个这样的水槽进去
I can send in one of these sink

1374
01:05:57,780 --> 01:06:03,180
有效地很好地
operations which is effectively well the

1375
01:06:03,180 --> 01:06:04,560
同步操作通过
sync operation makes its way through the

1376
01:06:04,560 --> 01:06:07,890
系统，就好像它是一次写入，而您
system as if it were a write and you

1377
01:06:07,890 --> 01:06:09,930
我知道最终会出现在我的日志里
know finally showing up in the logs of

1378
01:06:09,930 --> 01:06:12,690
这些复制品真的至少是
the replicas that really at least the

1379
01:06:12,690 --> 01:06:14,670
我正在与之交谈的复制品，然后我
replicas that I'm talking to and then I

1380
01:06:14,670 --> 01:06:18,160
可以回来读一读，你知道
can come back and do a read and you know

1381
01:06:18,160 --> 01:06:20,920
我能，我基本上能分辨出复制品
I can I can tell the replica basically

1382
01:06:20,920 --> 01:06:23,079
在你看完这份读物之前，不要提供这个读物
don't serve this read until you've seen

1383
01:06:23,079 --> 01:06:26,079
我的最后一个水槽，它真的掉了出来
my last sink and that actually falls out

1384
01:06:26,079 --> 01:06:29,190
当然是从第五个客户的订单开始，如果我们
naturally from fifl client order if we

1385
01:06:29,190 --> 01:06:33,039
如果我们向右倒下，那么5-0
if we countersink as a right then five-o

1386
01:06:33,039 --> 01:06:34,750
客户订单称需要读取以
client order says reads are required to

1387
01:06:34,750 --> 01:06:37,509
看你知道的州你知道至少有
see state you know there's as least as

1388
01:06:37,509 --> 01:06:39,130
最新的是从那以后的最后一条路。
up to date is the last right from that

1389
01:06:39,130 --> 01:06:41,410
客户端，所以如果我发送一个接收器，
client and so if I send in a sink and

1390
01:06:41,410 --> 01:06:45,160
然后我读到了我就是这个系统
then I do read I'm the the system is

1391
01:06:45,160 --> 01:06:47,410
有义务给我数据，那就是签证到期了
obliged to give me data that's visas up

1392
01:06:47,410 --> 01:06:49,960
到目前为止，我的水槽在原木中的位置
to date as where my sink fell in the log

1393
01:06:49,960 --> 01:06:52,269
如果我需要看书的话还是点吧
order anyway if I need to read

1394
01:06:52,269 --> 01:06:54,759
在接收器中发送最新数据，然后执行
up-to-date data send in a sink then do a

1395
01:06:54,759 --> 01:06:57,630
读取，并且读取保证会看到
read and the read is guaranteed to see

1396
01:06:57,630 --> 01:07:01,420
截至输入时的数据
data as of the time the same was entered

1397
01:07:01,420 --> 01:07:05,140
放到原木里，相当新鲜，所以
into the log so reasonably fresh so

1398
01:07:05,140 --> 01:07:06,730
那只是一只，但是很贵的。
that's one out but it's an expensive one

1399
01:07:06,730 --> 01:07:08,559
因为你现在我们把一个便宜的
because you now we converted a cheap

1400
01:07:08,559 --> 01:07:11,500
读入接收器操作，该接收器操作
read into the sink operation which

1401
01:07:11,500 --> 01:07:14,109
耗尽了领队的时间，所以这是一个
burned up time on the leader so it's a

1402
01:07:14,109 --> 01:07:17,859
不-不，如果你不需要的话，但这是
no-no if you don't have to do but here's

1403
01:07:17,859 --> 01:07:19,450
下面是几个场景示例，这些场景
a couple of examples of scenarios that

1404
01:07:19,450 --> 01:07:23,349
这篇论文谈到了这一推理
the paper talks about that the reasoning

1405
01:07:23,349 --> 01:07:25,660
关于它们的描述是简化的或合理的
about them is simplified or reasonably

1406
01:07:25,660 --> 01:07:27,759
很简单，考虑到这里的规则，所以
simple given the rules that are here so

1407
01:07:27,759 --> 01:07:29,349
首先，我想谈谈
first I want to talk about the trick in

1408
01:07:29,349 --> 01:07:32,619
第2.3节包含就绪文件，其中
section 2.3 of with the ready file where

1409
01:07:32,619 --> 01:07:34,809
我们假设有一些大师和
we assume there's some master and the

1410
01:07:34,809 --> 01:07:36,869
在中维护配置的大师级人员
Masters maintaining a configuration in

1411
01:07:36,869 --> 01:07:39,190
ZooKeeper是一堆文件和
zookeeper which is a bunch of files and

1412
01:07:39,190 --> 01:07:41,019
动物园管理员描述了你知道的
zookeeper that describe you know

1413
01:07:41,019 --> 01:07:43,150
关于我们的分布式系统
something about our distributed system

1414
01:07:43,150 --> 01:07:45,190
比如所有员工的IP地址
like the IP addresses of all the workers

1415
01:07:45,190 --> 01:07:48,910
也不知道主人是谁之类的，所以我们
or who the master is or something so we

1416
01:07:48,910 --> 01:07:51,190
更新这个的大师
the master who's updating this

1417
01:07:51,190 --> 01:07:52,630
配置，也许还有一堆
configuration and maybe a bunch of

1418
01:07:52,630 --> 01:07:54,130
需要阅读当前
readers that need to read the current

1419
01:07:54,130 --> 01:07:55,960
配置，并且需要每隔一段时间查看一次
configuration and need to see it every

1420
01:07:55,960 --> 01:07:57,819
时间会改变，所以问题是
time it changes and so the question is

1421
01:07:57,819 --> 01:07:59,529
你知道我们能不能建造一些
you know can we construct something that

1422
01:07:59,529 --> 01:08:02,349
即使在更新配置时
even though updating the configure even

1423
01:08:02,349 --> 01:08:03,460
尽管配置被拆分到
though the configuration is split across

1424
01:08:03,460 --> 01:08:05,920
在ZooKeeper中有很多文件，我们可以
many files in zookeeper we can have the

1425
01:08:05,920 --> 01:08:09,460
原子更新的效果，以便
effect of an atomic update so that

1426
01:08:09,460 --> 01:08:11,740
工人们看不到工人们在看着
workers don't see workers that look at

1427
01:08:11,740 --> 01:08:13,119
该配置没有看到一种
the configuration don't see a sort of

1428
01:08:13,119 --> 01:08:15,839
部分更新的配置，但仅限
partially updated configuration but only

1429
01:08:15,839 --> 01:08:19,839
一部完全更新的，那是一部经典之作
a completely updated that's a classic

1430
01:08:19,839 --> 01:08:23,469
这种配置
kind of thing that this configuration

1431
01:08:23,469 --> 01:08:25,920
动物园饲养员使用的管理
management that zookeeper people using

1432
01:08:25,920 --> 01:08:29,770
动物园管理员，所以你知道，看着
zookeeper for so you know looking at the

1433
01:08:29,770 --> 01:08:31,929
所以我们在复制2.3节
so we're copying what section 2.3

1434
01:08:31,929 --> 01:08:34,810
描述这会说主人是
describes this will say the master is

1435
01:08:34,810 --> 01:08:36,460
做了一系列的仪式来更新
doing a bunch of rites to update the

1436
01:08:36,460 --> 01:08:38,880
配置，下面是该配置的顺序
configuration and here's the order that

1437
01:08:38,880 --> 01:08:41,469
我们分布式系统的主站
the master for our distributed system

1438
01:08:41,469 --> 01:08:43,080
这些仪式是不是
does the rites

1439
01:08:43,080 --> 01:08:44,948
首先我们假设有一些准备好的
first we're assuming there's some ready

1440
01:08:44,948 --> 01:08:47,679
将名为Ready的文件归档，如果它们
file a file named ready and if they're

1441
01:08:47,679 --> 01:08:49,390
就绪文件存在，然后是配置
ready file exists then the configuration

1442
01:08:49,390 --> 01:08:50,679
我们被允许阅读
is we're allowed to read the

1443
01:08:50,679 --> 01:08:52,270
配置(如果它们已准备好文件)
configuration if they're ready files

1444
01:08:52,270 --> 01:08:53,890
缺少，这意味着配置是
missing that means the configuration is

1445
01:08:53,890 --> 01:08:55,270
不断更新，我们不应该去看
being updated and we shouldn't look at

1446
01:08:55,270 --> 01:08:58,000
所以如果主机要更新
it so if the master is gonna update the

1447
01:08:58,000 --> 01:08:59,350
配置文件首先要做的是
configuration file the very first thing

1448
01:08:59,350 --> 01:09:07,238
它所做的就是删除准备好的文件，然后
it does is delete the ready file then it

1449
01:09:07,238 --> 01:09:10,569
写的各种文件都很动物园管理员
writes the various files very zookeeper

1450
01:09:10,569 --> 01:09:13,839
对象的数据所在的文件
files that hold the data for the

1451
01:09:13,839 --> 01:09:15,520
配置可能需要很多文件
configuration might be a lot of files

1452
01:09:15,520 --> 01:09:17,859
鼻子，然后当它完全
nose and then when it's completely

1453
01:09:17,859 --> 01:09:19,540
更新了组成
updated all the files that make up the

1454
01:09:19,540 --> 01:09:24,149
配置，然后重新创建
configuration then it creates again

1455
01:09:24,149 --> 01:09:27,539
那是准备好的文件
that's ready file

1456
01:09:28,380 --> 01:09:31,960
好的，到目前为止，语义是
alright so so far the semantics are

1457
01:09:31,960 --> 01:09:33,670
非常直截了当，这只是
extremely straightforward this is just

1458
01:09:33,670 --> 01:09:35,140
权利这里只有权利没有读
rights there's only rights here no reads

1459
01:09:35,140 --> 01:09:37,000
保证在
rights are guaranteed to execute in

1460
01:09:37,000 --> 01:09:42,520
线性顺序，我想现在我们必须
linear order and I guess now we have to

1461
01:09:42,520 --> 01:09:44,408
如果对第五个客户订单提出上诉
appeal the fifl client order if the

1462
01:09:44,408 --> 01:09:46,630
大师会给这些贴上这样的标签，哦，你知道的
master sort of tags these as oh you know

1463
01:09:46,630 --> 01:09:48,399
我希望我的权利按照这个顺序发生
I want my rights to occur in this order

1464
01:09:48,399 --> 01:09:52,270
那么读者就有义务进入它们。
then the reader is obliged to enter them

1465
01:09:52,270 --> 01:09:53,859
按该顺序添加到复制的日志中
into the replicated log in that order

1466
01:09:53,859 --> 01:09:56,080
所以尽管你知道复制品是
and so though you know the replicas were

1467
01:09:56,080 --> 01:09:57,520
所有人都尽职尽责地
all dutifully execute these one at a

1468
01:09:57,520 --> 01:09:58,960
这时候他们都会删除准备好的文件
time they'll all delete the ready file

1469
01:09:58,960 --> 01:10:01,480
然后把这个权利用在那个权利上
then apply this right in that right and

1470
01:10:01,480 --> 01:10:03,429
然后再次创建就绪文件，以便
then create the ready file again so

1471
01:10:03,429 --> 01:10:05,590
这些是命令的权利
these are rights the orders

1472
01:10:05,590 --> 01:10:08,770
不过，对于阅读来说，还是很直截了当的
straightforward for the reads though

1473
01:10:08,770 --> 01:10:13,420
它是，它可能有一点，也许是
it's it's maybe a little bit maybe a

1474
01:10:13,420 --> 01:10:14,409
根据需要稍微多想几句
little more thinking as required

1475
01:10:14,409 --> 01:10:16,150
假设我们有一些工人需要
supposing we have some worker that needs

1476
01:10:16,150 --> 01:10:21,909
要读取当前配置，我们正在
to read the current configuration we're

1477
01:10:21,909 --> 01:10:25,239
假设这名工人首先
going to assume that this worker first

1478
01:10:25,239 --> 01:10:28,870
检查以查看就绪文件是否
checks to see whether the ready file

1479
01:10:28,870 --> 01:10:31,750
存在它不存在它会给你
exists it doesn't exist it's gonna you

1480
01:10:31,750 --> 01:10:33,550
了解睡眠，然后再试一次，让我们假设
know sleep and try again so let's assume

1481
01:10:33,550 --> 01:10:35,679
它确实存在，让我们假设我们假设
it does exist let's assume we assume

1482
01:10:35,679 --> 01:10:41,199
工作人员检查以查看
that the worker checks to see

1483
01:10:41,199 --> 01:10:44,060
如果就绪文件在
if the ready file exists after it's

1484
01:10:44,060 --> 01:10:46,640
再创造出来，所以你知道这是什么
recreated and so you know what this

1485
01:10:46,640 --> 01:10:48,050
意思是现在这些都是正确的要求
means now these are all right requests

1486
01:10:48,050 --> 01:10:49,429
发送给领导，这是一次阅读
sent to the leader this is a read

1487
01:10:49,429 --> 01:10:52,850
请求，这只是一个集中的请求
request that's just centrally whatever

1488
01:10:52,850 --> 01:10:56,840
复制与之对话的客户端，然后
replica the clients talking to and then

1489
01:10:56,840 --> 01:11:00,290
如果它存在，你知道它会显示为F1
if it exists you know it's gonna read f1

1490
01:11:00,290 --> 01:11:07,640
B那-有趣的是
and B that - the interesting thing that

1491
01:11:07,640 --> 01:11:10,429
FIFO客户订单保证如下
FIFO client order guarantees here is

1492
01:11:10,429 --> 01:11:17,600
如果这返回了真，那就是如果
that if this returned true that is if

1493
01:11:17,600 --> 01:11:18,860
客户端正在与之对话的复制副本
the replica the client was talking to

1494
01:11:18,860 --> 01:11:21,140
说是的那份文件是存在的那么你就知道
said yes that file exists then you know

1495
01:11:21,140 --> 01:11:24,760
尽管如此，这意味着
as were as that what that means is that

1496
01:11:24,760 --> 01:11:27,679
至少在这个设置中是这样的
at least with this setup is that as that

1497
01:11:27,679 --> 01:11:32,120
该副本实际拥有副本
replica that that replica had actually

1498
01:11:32,120 --> 01:11:33,880
已查看就绪文件的重新创建
seen the recreate of the ready file

1499
01:11:33,880 --> 01:11:38,179
对的，为了让这个存在看到
right in order for this exist to see to

1500
01:11:38,179 --> 01:11:41,290
查看就绪文件是否存在，因为
see the ready file exists and because

1501
01:11:41,290 --> 01:11:44,270
需要连续的读取操作
successive read operations are required

1502
01:11:44,270 --> 01:11:47,449
在漫长的道路上只向前行进
to march along only forwards in the long

1503
01:11:47,449 --> 01:11:49,790
而且永远不会倒退，这意味着你
and never backwards that means that you

1504
01:11:49,790 --> 01:11:52,190
知道客户端的副本是否
know if the replicas the client was

1505
01:11:52,190 --> 01:11:54,739
如果它真的是原木的话
talking to if it's log actually

1506
01:11:54,739 --> 01:11:56,449
包含，然后它执行此操作
contained and then it executes this

1507
01:11:56,449 --> 01:11:58,370
创建就绪文件，这意味着
creative the ready file that means that

1508
01:11:58,370 --> 01:12:02,060
后续客户端读取必须仅移动
subsequent client reads must move only

1509
01:12:02,060 --> 01:12:07,340
按您的权限顺序转发
forward in the sequence of rights you

1510
01:12:07,340 --> 01:12:09,199
我知道领队把它放进了日志里
know that the leader put into the log so

1511
01:12:09,199 --> 01:12:11,570
如果我们看到这个已经准备好了，那就意味着
if we saw this ready that means that the

1512
01:12:11,570 --> 01:12:13,610
读取发生在复制副本借口
read occurs that the replica excuse to

1513
01:12:13,610 --> 01:12:16,159
在这里右手边的某个地方阅读
read down here somewhere after the right

1514
01:12:16,159 --> 01:12:18,140
它创造了就绪，这意味着
that created the ready and that means

1515
01:12:18,140 --> 01:12:19,699
保证读数能够遵守
that the reads are guaranteed to observe

1516
01:12:19,699 --> 01:12:22,340
这些权利的影响，所以我们这样做
the effects of these rights so we do

1517
01:12:22,340 --> 01:12:24,170
实际上在这里得到了一些好处
actually get some benefit here some

1518
01:12:24,170 --> 01:12:25,690
推理得益于这样一个事实，即
reasoning benefit from the fact that

1519
01:12:25,690 --> 01:12:28,159
即使它不能完全线性化
even though it's not fully linearizable

1520
01:12:28,159 --> 01:12:30,710
这些权利是可线性化的，并且
the rights are linearizable and the

1521
01:12:30,710 --> 01:12:32,719
阅读必须以一种单调的方式阅读
reads have to read sort of monotonically

1522
01:12:32,719 --> 01:12:37,840
在时间上向前移动到日志是
move forward in time to the log yes

1523
01:12:38,120 --> 01:12:41,279
主题音乐
[Music]

1524
01:12:49,400 --> 01:12:52,110
是的，这是个很好的问题，所以你的
yeah so that's a great question so your

1525
01:12:52,110 --> 01:12:54,750
这个问题在所有的客户中都是很好的
question is well in all this client

1526
01:12:54,750 --> 01:12:56,670
知道你知道这是不是真的
knows you know if this is the real

1527
01:12:56,670 --> 01:12:58,470
创建者输入的场景
scenario that the creators entered in

1528
01:12:58,470 --> 01:13:01,800
日志，然后读取器到达
the log and then the read arrives at the

1529
01:13:01,800 --> 01:13:03,510
在该复制副本执行此操作之后的复制副本
replica after that replica executed this

1530
01:13:03,510 --> 01:13:04,560
令人毛骨悚然的准备好了，然后一切都好了
creepy ready then everything's

1531
01:13:04,560 --> 01:13:06,030
直截了当，但还有其他
straightforward but there's other

1532
01:13:06,030 --> 01:13:07,530
这些东西是什么样子的可能性
possibilities for how this stuff was

1533
01:13:07,530 --> 01:13:08,070
交错
interleaved

1534
01:13:08,070 --> 01:13:11,660
所以让我们来看一个更麻烦的
so let's look at a much more troubling

1535
01:13:11,660 --> 01:13:21,570
场景所以你提出的场景
scenario so the scenario you brought up

1536
01:13:21,570 --> 01:13:24,750
我恰好准备好谈论这件事
which I happen to be prepared to talk

1537
01:13:24,750 --> 01:13:28,530
关于那个，是的，你知道的
about is that yeah you know the the

1538
01:13:28,530 --> 01:13:31,800
在某个点上执行到
master at some point executed to a

1539
01:13:31,800 --> 01:13:36,840
删除READY，否则您会知道很久以前
delete of ready or you know way back in

1540
01:13:36,840 --> 01:13:40,710
给以前的某个大师这个大师计时
time some previous master this master

1541
01:13:40,710 --> 01:13:41,990
已创建就绪文件
created the ready file

1542
01:13:41,990 --> 01:13:44,790
您知道，在它完成更新
you know after it finished updating the

1543
01:13:44,790 --> 01:13:46,680
我要说的是，准备好了，因为我已经存在了
state I say ready for I existed for a

1544
01:13:46,680 --> 01:13:48,030
然后一些新的主人或者这个
while then some new master or this

1545
01:13:48,030 --> 01:13:48,870
师父需要更改
master needs to change the

1546
01:13:48,870 --> 01:13:50,280
配置释放就绪文件
configurations release the ready file

1547
01:13:50,280 --> 01:13:56,270
你知道这是不对的，对吧
you know it doesn't right right and

1548
01:13:56,270 --> 01:13:58,560
真正令人不安的是
what's really troubling is that the

1549
01:13:58,560 --> 01:14:00,630
需要读取此内容的客户端
client that needs to read this

1550
01:14:00,630 --> 01:14:02,990
配置可能已调用EXISTS
configuration might have called exists

1551
01:14:02,990 --> 01:14:06,630
要查看就绪文件是否存在于
to see whether the ready file exists at

1552
01:14:06,630 --> 01:14:12,750
这一次，好吧，你知道这一点
this time all right and you know at this

1553
01:14:12,750 --> 01:14:14,100
时间点是的，确定准备好的文件
point in time yeah sure the ready file

1554
01:14:14,100 --> 01:14:16,410
存在，然后时间流逝，客户端
exists then time passes and the client

1555
01:14:16,410 --> 01:14:18,900
为可能是
issues the reads for the maybe the

1556
01:14:18,900 --> 01:14:22,200
客户端读取生成以下内容的第一个文件
client reads the first file that makes

1557
01:14:22,200 --> 01:14:25,500
升级配置，但也许是因为你
up the configuration but maybe it you

1558
01:14:25,500 --> 01:14:26,580
然后它读取第二个文件
know and then it reads the second file

1559
01:14:26,580 --> 01:14:29,610
也许这个读取的文件完全来自于
maybe this file this read comes totally

1560
01:14:29,610 --> 01:14:32,690
在主服务器一直在更改
after the master has been changing the

1561
01:14:32,690 --> 01:14:35,220
配置，现在这位读者拥有
configurations so now this reader has

1562
01:14:35,220 --> 01:14:38,880
读一读这辆旧的F1损坏的混合动力车
read this damaged mix of f1 from the old

1563
01:14:38,880 --> 01:14:40,800
配置和新版本中的f2
configuration and f2 from the new

1564
01:14:40,800 --> 01:14:42,030
配置，没有理由
configuration there's no reason to

1565
01:14:42,030 --> 01:14:44,210
相信这将包含
believe that that's going to contain

1566
01:14:44,210 --> 01:14:46,350
除了损坏的信息以外的任何内容
anything other than broken information

1567
01:14:46,350 --> 01:14:49,320
所以第一个场景很棒
so so this first scenario was great the

1568
01:14:49,320 --> 01:14:52,830
场景是一场灾难，所以现在我们
scenario is a disaster and so now we're

1569
01:14:52,830 --> 01:14:54,379
开始进入到
starting to get into

1570
01:14:54,379 --> 01:14:57,979
类似于严重的挑战，这是一个
of like serious challenges which a

1571
01:14:57,979 --> 01:15:01,869
精心设计的API用于协调
carefully designed API for coordination

1572
01:15:01,869 --> 01:15:05,030
在分布式系统中的计算机之间
between machines in a distributed system

1573
01:15:05,030 --> 01:15:07,669
可能会帮助我们正确解决
might actually help us solve right

1574
01:15:07,669 --> 01:15:09,709
因为就像3号实验室一样，你知道你是
because like for lab 3 you know you're

1575
01:15:09,709 --> 01:15:11,599
我要建立一个PUT GET系统和一个
gonna build a put get system and a

1576
01:15:11,599 --> 01:15:13,899
简单的Lab 3式PUT猜题系统
simple lab 3 style put guessed system

1577
01:15:13,899 --> 01:15:15,739
你知道它会遇到这个问题
you know it would run into this problem

1578
01:15:15,739 --> 01:15:17,689
也就是没有任何工具来
too and just does not have any tools to

1579
01:15:17,689 --> 01:15:18,320
去处理它吧
deal with it

1580
01:15:18,320 --> 01:15:21,859
但是动物园管理员API实际上不仅仅是
but the zookeeper API actually is more

1581
01:15:21,859 --> 01:15:23,929
比这更聪明，它能应付得来
clever than this and it can cope with it

1582
01:15:23,929 --> 01:15:27,979
那么实际发生的事情是什么呢？
and so what actually happens the way you

1583
01:15:27,979 --> 01:15:29,780
实际上会使用Ooh Keeper的是
would actually use ooh keeper is that

1584
01:15:29,780 --> 01:15:32,599
当发送此消息的客户端存在时
when the client sent in this exists

1585
01:15:32,599 --> 01:15:35,719
请求询问此文件是否存在，并且
request to ask does this file exist and

1586
01:15:35,719 --> 01:15:37,249
会说这个文件不仅存在
would say not only does this file exist

1587
01:15:37,249 --> 01:15:41,570
但它会说你知道告诉我
but it would say you know tell me if it

1588
01:15:41,570 --> 01:15:44,030
EXISTS甚至在那个文件上设置了监视
exists even set a watch on that file

1589
01:15:44,030 --> 01:15:47,179
这意味着如果这些文件曾经被删除或
which means if the files ever deleted or

1590
01:15:47,179 --> 01:15:48,889
如果它不存在，如果它曾经被创建过
if it doesn't exist if it's ever created

1591
01:15:48,889 --> 01:15:51,439
但在这种情况下，如果它曾经是
but in this case if it if it is ever

1592
01:15:51,439 --> 01:15:55,599
删除了，请给我发个通知
deleted please send me a notification

1593
01:15:56,499 --> 01:16:01,760
此外，通知还包括
and furthermore the notifications that

1594
01:16:01,760 --> 01:16:04,579
动物园管理员让你知道这是
zookeeper sends you know it's a the

1595
01:16:04,579 --> 01:16:05,959
读者在这里，它只是在和一些
reader here it's only talking to some

1596
01:16:05,959 --> 01:16:08,209
复制副本这是所有复制副本正在执行的操作
replicas this is all the replicas doing

1597
01:16:08,209 --> 01:16:09,729
这些东西对它来说就是复制品
these things for it the replica

1598
01:16:09,729 --> 01:16:13,849
保证向您发送通知
guarantees to send a notification for

1599
01:16:13,849 --> 01:16:16,669
对此准备好的文件进行一些更改，请参阅
some change to this ready file at the

1600
01:16:16,669 --> 01:16:20,439
相对于回答的正确点
correct point relative to the responses

1601
01:16:20,439 --> 01:16:25,639
给客户的读数，那么这又是什么呢？
to the clients reads and so what that

1602
01:16:25,639 --> 01:16:32,389
意思是你知道，因为
means so you know because that the the

1603
01:16:32,389 --> 01:16:34,519
这意味着在这件事上
implication of that is that in this

1604
01:16:34,519 --> 01:16:38,449
您知道这些内容的场景
scenario in which you know these these

1605
01:16:38,449 --> 01:16:40,780
权利有点像是实时地放在这里
rights sort of fit in here in real time

1606
01:16:40,780 --> 01:16:44,030
可保证的是，如果您要求
the guarantee is that if you ask for a

1607
01:16:44,030 --> 01:16:45,679
看着一些东西，然后你就可以发布了
watch on something and then you issue

1608
01:16:45,679 --> 01:16:49,369
有些人读到如果你的复制品
some reads if that replica you're

1609
01:16:49,369 --> 01:16:51,379
谈话是为了执行一些应该做的事情
talking to execute something that should

1610
01:16:51,379 --> 01:16:53,629
在你的工作时间内触发手表
trigger the watch in during your

1611
01:16:53,629 --> 01:16:57,679
读取顺序，然后是复制副本
sequence of reads then the replica

1612
01:16:57,679 --> 01:16:59,449
保证将通知送达
guarantees to deliver the notification

1613
01:16:59,449 --> 01:17:02,090
关于手表的信息，然后它才会响应
about the watch before it responds to

1614
01:17:02,090 --> 01:17:05,300
任何你知道的读物都会看到
any read that came that you know saw the

1615
01:17:05,300 --> 01:17:07,840
在该点之后记录
log after the point

1616
01:17:07,840 --> 01:17:10,540
该操作所在的操作的
of the OP where the operation that

1617
01:17:10,540 --> 01:17:12,850
已触发手表通知
triggered the watch notification

1618
01:17:12,850 --> 01:17:15,320
执行，所以这是
executed and so this is the log on the

1619
01:17:15,320 --> 01:17:18,950
复制品，所以你知道如果是这样的话
replica and so you know if the so that

1620
01:17:18,950 --> 01:17:21,650
你知道FIFO客户的订单将会
you know the FIFO client ordering will

1621
01:17:21,650 --> 01:17:23,600
假设您知道每个客户端请求必须
say you know each client requests must

1622
01:17:23,600 --> 01:17:25,280
显然可以放在原木的某个地方
fit somewhere into the log apparently

1623
01:17:25,280 --> 01:17:27,800
这些都在日志里符合我们正在做的事
these fit in here in the log what we're

1624
01:17:27,800 --> 01:17:29,930
担心的是这种读取会发生
worried about is that this read occurs

1625
01:17:29,930 --> 01:17:32,090
在日志里，但是我们设置了这个表
here in the log but we set up this watch

1626
01:17:32,090 --> 01:17:34,400
而保证就是它将会收到
and the guarantee is that will receive

1627
01:17:34,400 --> 01:17:36,500
如果有人删除了此内容，请注意
the note if if somebody deletes this

1628
01:17:36,500 --> 01:17:39,200
文件，然后我们可以通知您
file and we can notified then that

1629
01:17:39,200 --> 01:17:40,940
通知将出现在
notification will will appear at the

1630
01:17:40,940 --> 01:17:43,610
客户端在读取之前生成
client before a read that yields

1631
01:17:43,610 --> 01:17:48,470
日志中随后的任何内容都将
anything subsequently in the log will

1632
01:17:48,470 --> 01:17:49,940
在我们收到
get the notification before we get the

1633
01:17:49,940 --> 01:17:52,370
任何阅读的结果，也就是看到
results of any read that's that saw

1634
01:17:52,370 --> 01:17:54,890
手术后日志里有什么东西
something in log after the operation

1635
01:17:54,890 --> 01:17:57,080
产生了通知，那又怎么样？
that produced the notification so what

1636
01:17:57,080 --> 01:17:58,820
这意味着删除就绪状态为
this means that the delete ready is

1637
01:17:58,820 --> 01:18:00,650
既然我们已经准备好了一块手表
gonna since we have a watch on the ready

1638
01:18:00,650 --> 01:18:02,330
精英们准备好了要提交的文件
file that elite ready is going to

1639
01:18:02,330 --> 01:18:05,420
生成通知，并且
generate a notification and that

1640
01:18:05,420 --> 01:18:07,130
保证通知是
notification is guaranteed to be

1641
01:18:07,130 --> 01:18:10,000
在f2的读取结果之前传递
delivered before the read result of f2

1642
01:18:10,000 --> 01:18:13,340
如果f2看对了这一秒
if f2 was gonna see this second right

1643
01:18:13,340 --> 01:18:15,380
这意味着在阅读之前
and that means that before the reading

1644
01:18:15,380 --> 01:18:17,510
客户端已在以下位置完成序列
client has finished the sequence in

1645
01:18:17,510 --> 01:18:19,220
它会查看它的配置
which it looks at the configuration it's

1646
01:18:19,220 --> 01:18:23,230
保证看到手表通知
guaranteed to see the watch notification

1647
01:18:23,230 --> 01:18:26,900
在它看到任何写入结果之前
before it sees the results of any write

1648
01:18:26,900 --> 01:18:29,840
那是在这个删除那个之后发生的
that happened after this delete that

1649
01:18:29,840 --> 01:18:32,770
已触发通知
triggered the notification

1650
01:18:39,320 --> 01:18:42,510
是谁生产的手表，也是由谁生产的
who generates the watch as well the

1651
01:18:42,510 --> 01:18:43,770
复制副本假设客户端正在通话
replica let's say the client is talking

1652
01:18:43,770 --> 01:18:45,659
发送到此复制副本，并且它将
to this replica and it sends in the

1653
01:18:45,659 --> 01:18:48,150
EXISTS请求EXIST文件室已读取
exists request the exist room has a read

1654
01:18:48,150 --> 01:18:49,679
仅与他的复制品一起发送的请求
only request it sends with his replica

1655
01:18:49,679 --> 01:18:51,659
复制品正被画在
the replica is being painting on the

1656
01:18:51,659 --> 01:18:54,000
在一桌手表旁说“哦，你”
side a table of watches saying oh you

1657
01:18:54,000 --> 01:18:55,440
知道某某客户要求提供
know such-and-such a client asked for a

1658
01:18:55,440 --> 01:18:59,429
请关注此文件，并进一步查看
watch on this file and furthermore the

1659
01:18:59,429 --> 01:19:01,590
值班是在特定的Z位置建立的
watch was established at a particular Z

1660
01:19:01,590 --> 01:19:03,840
客户端读取的X ID
X ID that is did a read that client did

1661
01:19:03,840 --> 01:19:05,969
对执行的复制副本执行的读取
a read with the replica executed the

1662
01:19:05,969 --> 01:19:07,920
此时在日志中读取并返回
read at this point in the log and return

1663
01:19:07,920 --> 01:19:09,630
结果是相对于
results are relative to this point in

1664
01:19:09,630 --> 01:19:12,540
会员欠手表的日志是
the log members owe that watch is

1665
01:19:12,540 --> 01:19:14,070
相对于日志中该点，且
relative to that point in the log and

1666
01:19:14,070 --> 01:19:17,400
然后，如果出现删除操作，您知道
then if a delete comes in you know for

1667
01:19:17,400 --> 01:19:20,280
每一个有q的操作都是如此
every operation that there s Q so it

1668
01:19:20,280 --> 01:19:21,540
看着这张小桌子，上面写着啊哈
looks in this little table it says aha

1669
01:19:21,540 --> 01:19:24,540
你知道吗，那上面有块表
you know the a there was a watch on that

1670
01:19:24,540 --> 01:19:27,000
文件，并且可能通过散列
file and maybe it's indexed by hash of

1671
01:19:27,000 --> 01:19:29,810
文件名或其他什么
filename or something

1672
01:19:37,440 --> 01:19:39,820
好的，那么问题是，哦，是的，这个
okay so the question is oh yeah this

1673
01:19:39,820 --> 01:19:41,889
此副本必须具有监视表
this replica has to have a watch table

1674
01:19:41,889 --> 01:19:46,060
你知道如果副本崩溃，
you know if the replica crashes and the

1675
01:19:46,060 --> 01:19:48,579
客户端是正式不同的副本
client is officially different replica

1676
01:19:48,579 --> 01:19:50,170
你知道表台怎么样吗？
you know what about the watch table

1677
01:19:50,170 --> 01:19:51,159
好的，这些已经确定了。
right it's already established these

1678
01:19:51,159 --> 01:19:52,780
看吧，答案是不会的。
watch and the answer to that is that no

1679
01:19:52,780 --> 01:19:56,739
您的复制副本的代表会使新的
the rep your replica crashes the new

1680
01:19:56,739 --> 01:19:58,570
您切换到的复本不会有
replica you switch to won't have the

1681
01:19:58,570 --> 01:20:01,360
观察表，但是客户端会得到一个
watch table and but the client gets a

1682
01:20:01,360 --> 01:20:03,610
在以下位置的适当时刻发出通知
notification at the appropriate point in

1683
01:20:03,610 --> 01:20:06,429
在一连串的响应中，它会返回
in the stream of responses it gets back

1684
01:20:06,429 --> 01:20:08,949
说不出你的复制品你是
saying oops your replica you were

1685
01:20:08,949 --> 01:20:11,710
和你谈话的时候坠毁了，所以客户
talking to you crashed and so the client

1686
01:20:11,710 --> 01:20:13,480
然后知道它必须完全重置
then knows it has to completely reset up

1687
01:20:13,480 --> 01:20:16,750
所有的东西都藏在里面
everything and so tucked away in in the

1688
01:20:16,750 --> 01:20:20,079
例如，缺少以下事件处理程序
examples are missing event handlers to

1689
01:20:20,079 --> 01:20:21,940
说，哦，天哪，你知道我们需要回去
say oh gosh you know we need to go back

1690
01:20:21,940 --> 01:20:24,550
如果我们得到一个
and we establish everything if we get a

1691
01:20:24,550 --> 01:20:26,500
通知我们的副本崩溃了
notification that our replicas crashed

1692
01:20:26,500 --> 00:00:00,000
好的，我会继续的。
all right I'll continuous

